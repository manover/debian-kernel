--- a/Documentation/hwmon/it87
+++ b/Documentation/hwmon/it87
@@ -6,9 +6,17 @@ Supported chips:
     Prefix: 'it8603'
     Addresses scanned: from Super I/O config space (8 I/O ports)
     Datasheet: Not publicly available
+  * IT8613E
+    Prefix: 'it8613'
+    Addresses scanned: from Super I/O config space (8 I/O ports)
+    Datasheet: Not publicly available
   * IT8620E
     Prefix: 'it8620'
     Addresses scanned: from Super I/O config space (8 I/O ports)
+  * IT8622E
+    Prefix: 'it8622'
+    Addresses scanned: from Super I/O config space (8 I/O ports)
+    Datasheet: Not publicly available
   * IT8628E
     Prefix: 'it8628'
     Addresses scanned: from Super I/O config space (8 I/O ports)
@@ -117,10 +125,10 @@ motherboard models.
 Description
 -----------
 
-This driver implements support for the IT8603E, IT8620E, IT8623E, IT8628E,
-IT8705F, IT8712F, IT8716F, IT8718F, IT8720F, IT8721F, IT8726F, IT8728F, IT8732F,
-IT8758E, IT8771E, IT8772E, IT8781F, IT8782F, IT8783E/F, IT8786E, IT8790E, and
-SiS950 chips.
+This driver implements support for the IT8603E, IT8620E, IT8622E, IT8623E,
+IT8628E, IT8705F, IT8712F, IT8716F, IT8718F, IT8720F, IT8721F, IT8726F, IT8728F,
+IT8732F, IT8758E, IT8771E, IT8772E, IT8781F, IT8782F, IT8783E/F, IT8786E,
+IT8790E, and SiS950 chips.
 
 These chips are 'Super I/O chips', supporting floppy disks, infrared ports,
 joysticks and other miscellaneous stuff. For hardware monitoring, they
@@ -272,3 +280,58 @@ temperature for thermal diodes or diode-
 If a temperature sensor is configured for thermistors, the attribute values
 are ignored. If the thermal sensor type is Intel PECI, the temperature offset
 must be programmed to the critical CPU temperature.
+
+Preliminary support
+-------------------
+
+Support for IT8607E, IT8665E, and IT8686E is preliminary. Voltage readings,
+temperature readings, fan control, and fan speed measurements may be wrong
+and/or missing. Fan control and fan speed may be enabled and reported for
+non-existing fans. Please report any problems and inconsistencies.
+
+Reporting information for unsupported chips
+-------------------------------------------
+
+If the chip in your system is not yet supported by the driver, please provide
+the following information.
+
+First, run sensors-detect. It will tell you something like
+
+    Probing for Super-I/O at 0x2e/0x2f
+    ...
+    Trying family `ITE'...                                      Yes
+    Found unknown chip with ID 0x8665
+	(logical device 4 has address 0x290, could be sensors)
+
+With this information, run the following commands.
+
+sudo isadump -k 0x87,0x01,0x55,0x55 0x2e 0x2f 7
+sudo isadump 0x295 0x296
+
+and report the results.
+
+The addresses in the first command are from "Probing for Super-I/O at
+0x2e/0x2f". Use those addresses in the first command.
+    sudo isadump -k 0x87,0x01,0x55,0x55 0x2e 0x2f 7
+
+The addresses in the second command are from "has address 0x290".
+Add 5 and 6 to this address for the next command.
+    sudo isadump 0x295 0x296
+
+Next, force-install the driver by providing one of the already supported chips
+as forced ID. Useful IDs to test are 0x8622, 0x8628, 0x8728, and 0x8732, though
+feel free to test more IDs. For each ID, instantiate the driver as follows
+(this example is instantiating driver with ID 0x8622).
+	sudo modprobe it87 force_id=0x8622
+After entering this command, run the "sensors" command and provide the output.
+Then unload the driver with
+	sudo modprobe -r it87
+Repeat with different chip IDs, and report each result.
+
+Please also report your board type as well as voltages and fan settings from
+the BIOS. If possible, connect fans to different fan headers and let us know
+if all fans are detected and reported.
+
+This information _might_ give us enough information to add experimental support
+for the chip in question. No guarantees, though - unless a datasheet is
+available, something is likely to be wrong.
--- a/drivers/hwmon/Kconfig
+++ b/drivers/hwmon/Kconfig
@@ -649,6 +649,54 @@ config SENSORS_IT87
 	  This driver can also be built as a module.  If so, the module
 	  will be called it87.
 
+config SENSORS_IT87_USE_ACPI_MUTEX
+	bool "Experimental ACPI mutex on IT87 SIO" if EXPERT
+	depends on SENSORS_IT87
+	default n
+	select ACPI_MUTEX
+	help
+		There is a (currently small) list of motherboards who play nice
+		with ACPI native mutex primitives (and also some boards may not
+		work correctly without this experimental feature. If your firmware
+		defines a mutex object for the IT87xxxx super IO chip in the ACPI
+		tables or your motherboard is on the DMI table of the supported
+		hardware in it87.c, you may want to enable this parameter.
+		In case	your MB is not defined in the DMI table, you must also
+		define the correct path to the mutex below.
+
+		It goes without saying that should you test your configuration
+		successfully, you are highly encouraged to forward your findings
+		upstream and earn a great deal of karma from your fellow device
+		owners.
+
+config SENSORS_IT87_ACPI_MUTEX_CUSTOM
+	bool "Manually define custom ACPI mutex path for IT87xxxx SIO"
+	depends on SENSORS_IT87_USE_ACPI_MUTEX
+	default n
+	help
+		This config parameter allows you to define IT87xxxx SIO mutex path for
+		your custom system. This allows the driver to use ACPI mutex even if
+		your board is not (yet)	included in the list of supported hardware.
+		Decompile your ACPI tables and look it up. You must leave this parameter
+		disabled if there is no mutex defined in the tables even if your board
+		has IT87xxxx SIO on it. If you define an incorrect path, the controller
+		might become inoperable or even crash the system.
+		The mutex path found in the ACPI tables always overrides this parameter.
+
+		If you are not sure what this all means, please leave this parameter disabled.
+
+config SENSORS_IT87_ACPI_MUTEX_PATH
+	string ""
+	depends on SENSORS_IT87_ACPI_MUTEX_CUSTOM
+	default "\\_SB.PCI0.xxxx.SIOx.MUTx"
+	help
+		The typical IT87 ACPI mutex path starts with "\_SB.PCIx." and looks like a
+		list of dot-separated 4-character components.
+
+		Examples:
+		  "\_SB.PCI0.LPCB.SIO1.MUT0"
+		  "\_SB.PCI0.SBRG.SIO2.MUT1"
+
 config SENSORS_JZ4740
 	tristate "Ingenic JZ4740 SoC ADC driver"
 	depends on MACH_JZ4740 && MFD_JZ4740_ADC
--- a/drivers/hwmon/it87.c
+++ b/drivers/hwmon/it87.c
@@ -11,10 +11,16 @@
  *  similar parts.  The other devices are supported by different drivers.
  *
  *  Supports: IT8603E  Super I/O chip w/LPC interface
+ *            IT8607E  Super I/O chip w/LPC interface
+ *            IT8613E  Super I/O chip w/LPC interface
  *            IT8620E  Super I/O chip w/LPC interface
  *            IT8622E  Super I/O chip w/LPC interface
  *            IT8623E  Super I/O chip w/LPC interface
+ *            IT8625E  Super I/O chip w/LPC interface
  *            IT8628E  Super I/O chip w/LPC interface
+ *            IT8655E  Super I/O chip w/LPC interface
+ *            IT8665E  Super I/O chip w/LPC interface
+ *            IT8686E  Super I/O chip w/LPC interface
  *            IT8705F  Super I/O chip w/LPC interface
  *            IT8712F  Super I/O chip w/LPC interface
  *            IT8716F  Super I/O chip w/LPC interface
@@ -72,13 +78,23 @@
 
 enum chips { it87, it8712, it8716, it8718, it8720, it8721, it8728, it8732,
 	     it8771, it8772, it8781, it8782, it8783, it8786, it8790,
-	     it8792, it8603, it8620, it8622, it8628 };
+	     it8792, it8603, it8607, it8613, it8620, it8622, it8625, it8628,
+	     it8655, it8665, it8686 };
 
 static unsigned short force_id;
 module_param(force_id, ushort, 0);
 MODULE_PARM_DESC(force_id, "Override the detected device ID");
 
+static unsigned short blacklist = 1;
+module_param(blacklist, ushort, 0);
+MODULE_PARM_DESC(blacklist,
+		 "Enable/disable blacklist (1=enable, 0=disable, default 1)");
+
 static struct platform_device *it87_pdev[2];
+static bool it87_sio4e_broken;
+#ifdef CONFIG_SENSORS_IT87_USE_ACPI_MUTEX
+static acpi_handle acpi_sio_mutex;
+#endif
 
 #define	REG_2E	0x2e	/* The register to read/write */
 #define	REG_4E	0x4e	/* Secondary register to read/write */
@@ -86,6 +102,9 @@ static struct platform_device *it87_pdev
 #define	DEV	0x07	/* Register: Logical device select */
 #define PME	0x04	/* The device with the fan registers in it */
 
+#define IS_REG(R, x)		(x == REG_##R)
+#define IS_NOT_REG(R, x)	(x != REG_##R)
+
 /* The device with the IT8718F/IT8720F VID value in it */
 #define GPIO	0x07
 
@@ -94,8 +113,26 @@ static struct platform_device *it87_pdev
 
 static inline int superio_inb(int ioreg, int reg)
 {
+	int val;
+
 	outb(reg, ioreg);
-	return inb(ioreg + 1);
+	val = inb(ioreg + 1);
+
+	if (it87_sio4e_broken && IS_REG(4E, ioreg) && val == 0xff) {
+		/* Garbage response on sio4e broken device, try to
+		 * re-enter */
+		outb(0x87, ioreg);
+		outb(0x01, ioreg);
+		outb(0x55, ioreg);
+		outb(0xaa, ioreg);
+
+		/* and re-read */
+		outb(reg, ioreg);
+		val = inb(ioreg + 1);
+		pr_warn("Retry access 0x4e:0x%x -> 0x%x\n", reg, val);
+	}
+
+	return val;
 }
 
 static inline void superio_outb(int ioreg, int reg, int val)
@@ -106,13 +143,7 @@ static inline void superio_outb(int iore
 
 static int superio_inw(int ioreg, int reg)
 {
-	int val;
-
-	outb(reg++, ioreg);
-	val = inb(ioreg + 1) << 8;
-	outb(reg, ioreg);
-	val |= inb(ioreg + 1);
-	return val;
+	return (superio_inb(ioreg, reg) << 8) | superio_inb(ioreg, reg + 1);
 }
 
 static inline void superio_select(int ioreg, int ldn)
@@ -123,24 +154,49 @@ static inline void superio_select(int io
 
 static inline int superio_enter(int ioreg)
 {
+#ifdef CONFIG_SENSORS_IT87_USE_ACPI_MUTEX
+	if (acpi_sio_mutex) {
+		acpi_status status;
+
+		status = acpi_acquire_mutex(acpi_sio_mutex, NULL, 0x10);
+		if (ACPI_FAILURE(status)) {
+			pr_err("Failed to acquire ACPI mutex\n");
+			return -EBUSY;
+		}
+	}
+#endif
 	/*
 	 * Try to reserve ioreg and ioreg + 1 for exclusive access.
 	 */
 	if (!request_muxed_region(ioreg, 2, DRVNAME))
-		return -EBUSY;
+		goto error;
 
 	outb(0x87, ioreg);
 	outb(0x01, ioreg);
 	outb(0x55, ioreg);
-	outb(ioreg == REG_4E ? 0xaa : 0x55, ioreg);
+	outb(IS_REG(4E, ioreg) ? 0xaa : 0x55, ioreg);
+
 	return 0;
+
+error:
+#ifdef CONFIG_SENSORS_IT87_USE_ACPI_MUTEX
+	if (acpi_sio_mutex)
+		acpi_release_mutex(acpi_sio_mutex, NULL);
+#endif
+	return -EBUSY;
 }
 
 static inline void superio_exit(int ioreg)
 {
-	outb(0x02, ioreg);
-	outb(0x02, ioreg + 1);
+	if (!it87_sio4e_broken || IS_NOT_REG(4E, ioreg)) {
+		outb(0x02, ioreg);
+		outb(0x02, ioreg + 1);
+	}
 	release_region(ioreg, 2);
+#ifdef CONFIG_SENSORS_IT87_USE_ACPI_MUTEX
+	if (acpi_sio_mutex)
+		acpi_release_mutex(acpi_sio_mutex, NULL);
+#endif
 }
 
 /* Logical device 4 registers */
@@ -162,10 +218,16 @@ static inline void superio_exit(int iore
 #define IT8786E_DEVID 0x8786
 #define IT8790E_DEVID 0x8790
 #define IT8603E_DEVID 0x8603
+#define IT8607E_DEVID 0x8607
+#define IT8613E_DEVID 0x8613
 #define IT8620E_DEVID 0x8620
 #define IT8622E_DEVID 0x8622
 #define IT8623E_DEVID 0x8623
+#define IT8625E_DEVID 0x8625
 #define IT8628E_DEVID 0x8628
+#define IT8655E_DEVID 0x8655
+#define IT8665E_DEVID 0x8665
+#define IT8686E_DEVID 0x8686
 #define IT87_ACT_REG  0x30
 #define IT87_BASE_REG 0x60
 
@@ -175,8 +237,10 @@ static inline void superio_exit(int iore
 #define IT87_SIO_GPIO3_REG	0x27
 #define IT87_SIO_GPIO4_REG	0x28
 #define IT87_SIO_GPIO5_REG	0x29
+#define IT87_SIO_GPIO9_REG	0xd3
 #define IT87_SIO_PINX1_REG	0x2a	/* Pin selection */
 #define IT87_SIO_PINX2_REG	0x2c	/* Pin selection */
+#define IT87_SIO_PINX4_REG	0x2d	/* Pin selection */
 #define IT87_SIO_SPI_REG	0xef	/* SPI function pin select */
 #define IT87_SIO_VID_REG	0xfc	/* VID value */
 #define IT87_SIO_BEEP_PIN_REG	0xf6	/* Beep pin mapping */
@@ -210,6 +274,8 @@ static bool fix_pwm_polarity;
 #define IT87_REG_ALARM2        0x02
 #define IT87_REG_ALARM3        0x03
 
+#define IT87_REG_BANK		0x06
+
 /*
  * The IT8718F and IT8720F have the VID value in a different register, in
  * Super-I/O configuration space.
@@ -230,16 +296,29 @@ static bool fix_pwm_polarity;
  * - up to 6 fan (1 to 6)
  */
 
-static const u8 IT87_REG_FAN[]         = { 0x0d, 0x0e, 0x0f, 0x80, 0x82, 0x4c };
-static const u8 IT87_REG_FAN_MIN[]     = { 0x10, 0x11, 0x12, 0x84, 0x86, 0x4e };
-static const u8 IT87_REG_FANX[]        = { 0x18, 0x19, 0x1a, 0x81, 0x83, 0x4d };
-static const u8 IT87_REG_FANX_MIN[]    = { 0x1b, 0x1c, 0x1d, 0x85, 0x87, 0x4f };
-static const u8 IT87_REG_TEMP_OFFSET[] = { 0x56, 0x57, 0x59 };
+static const u8 IT87_REG_FAN[] =	{ 0x0d, 0x0e, 0x0f, 0x80, 0x82, 0x4c };
+static const u8 IT87_REG_FAN_MIN[] =	{ 0x10, 0x11, 0x12, 0x84, 0x86, 0x4e };
+static const u8 IT87_REG_FANX[] =	{ 0x18, 0x19, 0x1a, 0x81, 0x83, 0x4d };
+static const u8 IT87_REG_FANX_MIN[] =	{ 0x1b, 0x1c, 0x1d, 0x85, 0x87, 0x4f };
+
+static const u8 IT87_REG_FAN_8665[] =	{ 0x0d, 0x0e, 0x0f, 0x80, 0x82, 0x93 };
+static const u8 IT87_REG_FAN_MIN_8665[] =
+					{ 0x10, 0x11, 0x12, 0x84, 0x86, 0xb2 };
+static const u8 IT87_REG_FANX_8665[] =	{ 0x18, 0x19, 0x1a, 0x81, 0x83, 0x94 };
+static const u8 IT87_REG_FANX_MIN_8665[] =
+					{ 0x1b, 0x1c, 0x1d, 0x85, 0x87, 0xb3 };
+
+static const u8 IT87_REG_TEMP_OFFSET[] = { 0x56, 0x57, 0x59, 0x5a, 0x90, 0x91 };
+
+static const u8 IT87_REG_TEMP_OFFSET_8686[] = { 0x56, 0x57, 0x59, 0x90, 0x91, 0x92 };
 
 #define IT87_REG_FAN_MAIN_CTRL 0x13
 #define IT87_REG_FAN_CTL       0x14
-static const u8 IT87_REG_PWM[]         = { 0x15, 0x16, 0x17, 0x7f, 0xa7, 0xaf };
-static const u8 IT87_REG_PWM_DUTY[]    = { 0x63, 0x6b, 0x73, 0x7b, 0xa3, 0xab };
+
+static const u8 IT87_REG_PWM[] =	{ 0x15, 0x16, 0x17, 0x7f, 0xa7, 0xaf };
+static const u8 IT87_REG_PWM_8665[] =	{ 0x15, 0x16, 0x17, 0x1e, 0x1f, 0x92 };
+
+static const u8 IT87_REG_PWM_DUTY[] =	{ 0x63, 0x6b, 0x73, 0x7b, 0xa3, 0xab };
 
 static const u8 IT87_REG_VIN[]	= { 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26,
 				    0x27, 0x28, 0x2f, 0x2c, 0x2d, 0x2e };
@@ -248,8 +327,14 @@ static const u8 IT87_REG_VIN[]	= { 0x20,
 
 #define IT87_REG_VIN_MAX(nr)   (0x30 + (nr) * 2)
 #define IT87_REG_VIN_MIN(nr)   (0x31 + (nr) * 2)
-#define IT87_REG_TEMP_HIGH(nr) (0x40 + (nr) * 2)
-#define IT87_REG_TEMP_LOW(nr)  (0x41 + (nr) * 2)
+
+static const u8 IT87_REG_TEMP_HIGH[] =	{ 0x40, 0x42, 0x44, 0x46, 0xb4, 0xb6 };
+static const u8 IT87_REG_TEMP_LOW[] =	{ 0x41, 0x43, 0x45, 0x47, 0xb5, 0xb7 };
+
+static const u8 IT87_REG_TEMP_HIGH_8686[] =
+					{ 0x40, 0x42, 0x44, 0xb4, 0xb6, 0xb8 };
+static const u8 IT87_REG_TEMP_LOW_8686[] =
+					{ 0x41, 0x43, 0x45, 0xb5, 0xb7, 0xb9 };
 
 #define IT87_REG_VIN_ENABLE    0x50
 #define IT87_REG_TEMP_ENABLE   0x51
@@ -265,11 +350,12 @@ static const u8 IT87_REG_AUTO_BASE[] = {
 
 #define IT87_REG_TEMP456_ENABLE	0x77
 
+static const u16 IT87_REG_TEMP_SRC1[] =	{ 0x21d, 0x21e, 0x21f };
+#define IT87_REG_TEMP_SRC2	0x23d
+
 #define NUM_VIN			ARRAY_SIZE(IT87_REG_VIN)
 #define NUM_VIN_LIMIT		8
 #define NUM_TEMP		6
-#define NUM_TEMP_OFFSET		ARRAY_SIZE(IT87_REG_TEMP_OFFSET)
-#define NUM_TEMP_LIMIT		3
 #define NUM_FAN			ARRAY_SIZE(IT87_REG_FAN)
 #define NUM_FAN_DIV		3
 #define NUM_PWM			ARRAY_SIZE(IT87_REG_PWM)
@@ -279,6 +365,7 @@ struct it87_devices {
 	const char *name;
 	const char * const suffix;
 	u32 features;
+	u8 num_temp_limit;
 	u8 peci_mask;
 	u8 old_peci_mask;
 };
@@ -302,31 +389,44 @@ struct it87_devices {
 #define FEAT_PWM_FREQ2		BIT(16)	/* Separate pwm freq 2 */
 #define FEAT_SIX_TEMP		BIT(17)	/* Up to 6 temp sensors */
 #define FEAT_VIN3_5V		BIT(18)	/* VIN3 connected to +5V */
+#define FEAT_FOUR_FANS		BIT(19)	/* Supports four fans */
+#define FEAT_FOUR_PWM		BIT(20)	/* Supports four fan controls */
+#define FEAT_BANK_SEL		BIT(21)	/* Chip has multi-bank support */
+#define FEAT_SCALING		BIT(22)	/* Internal voltage scaling */
+#define FEAT_FANCTL_ONOFF	BIT(23)	/* chip has FAN_CTL ON/OFF */
+#define FEAT_11MV_ADC		BIT(24)
+#define FEAT_NEW_TEMPMAP	BIT(25)	/* new temp input selection */
 
 static const struct it87_devices it87_devices[] = {
 	[it87] = {
 		.name = "it87",
 		.suffix = "F",
-		.features = FEAT_OLD_AUTOPWM,	/* may need to overwrite */
+		.features = FEAT_OLD_AUTOPWM | FEAT_FANCTL_ONOFF,
+						/* may need to overwrite */
+		.num_temp_limit = 3,
 	},
 	[it8712] = {
 		.name = "it8712",
 		.suffix = "F",
-		.features = FEAT_OLD_AUTOPWM | FEAT_VID,
+		.features = FEAT_OLD_AUTOPWM | FEAT_VID | FEAT_FANCTL_ONOFF,
 						/* may need to overwrite */
+		.num_temp_limit = 3,
 	},
 	[it8716] = {
 		.name = "it8716",
 		.suffix = "F",
 		.features = FEAT_16BIT_FANS | FEAT_TEMP_OFFSET | FEAT_VID
-		  | FEAT_FAN16_CONFIG | FEAT_FIVE_FANS | FEAT_PWM_FREQ2,
+		  | FEAT_FAN16_CONFIG | FEAT_FIVE_FANS | FEAT_PWM_FREQ2
+		  | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
 	},
 	[it8718] = {
 		.name = "it8718",
 		.suffix = "F",
 		.features = FEAT_16BIT_FANS | FEAT_TEMP_OFFSET | FEAT_VID
 		  | FEAT_TEMP_OLD_PECI | FEAT_FAN16_CONFIG | FEAT_FIVE_FANS
-		  | FEAT_PWM_FREQ2,
+		  | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
 		.old_peci_mask = 0x4,
 	},
 	[it8720] = {
@@ -334,7 +434,8 @@ static const struct it87_devices it87_de
 		.suffix = "F",
 		.features = FEAT_16BIT_FANS | FEAT_TEMP_OFFSET | FEAT_VID
 		  | FEAT_TEMP_OLD_PECI | FEAT_FAN16_CONFIG | FEAT_FIVE_FANS
-		  | FEAT_PWM_FREQ2,
+		  | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
 		.old_peci_mask = 0x4,
 	},
 	[it8721] = {
@@ -343,7 +444,8 @@ static const struct it87_devices it87_de
 		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
 		  | FEAT_TEMP_OFFSET | FEAT_TEMP_OLD_PECI | FEAT_TEMP_PECI
 		  | FEAT_FAN16_CONFIG | FEAT_FIVE_FANS | FEAT_IN7_INTERNAL
-		  | FEAT_PWM_FREQ2,
+		  | FEAT_PWM_FREQ2 | FEAT_SCALING | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
 		.peci_mask = 0x05,
 		.old_peci_mask = 0x02,	/* Actually reports PCH */
 	},
@@ -352,7 +454,9 @@ static const struct it87_devices it87_de
 		.suffix = "F",
 		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
 		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_FIVE_FANS
-		  | FEAT_IN7_INTERNAL | FEAT_PWM_FREQ2,
+		  | FEAT_IN7_INTERNAL | FEAT_PWM_FREQ2 | FEAT_SCALING
+		  | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
 		.peci_mask = 0x07,
 	},
 	[it8732] = {
@@ -360,7 +464,9 @@ static const struct it87_devices it87_de
 		.suffix = "F",
 		.features = FEAT_NEWER_AUTOPWM | FEAT_16BIT_FANS
 		  | FEAT_TEMP_OFFSET | FEAT_TEMP_OLD_PECI | FEAT_TEMP_PECI
-		  | FEAT_10_9MV_ADC | FEAT_IN7_INTERNAL,
+		  | FEAT_10_9MV_ADC | FEAT_IN7_INTERNAL | FEAT_FOUR_FANS
+		  | FEAT_FOUR_PWM | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
 		.peci_mask = 0x07,
 		.old_peci_mask = 0x02,	/* Actually reports PCH */
 	},
@@ -369,11 +475,12 @@ static const struct it87_devices it87_de
 		.suffix = "E",
 		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
 		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_IN7_INTERNAL
-		  | FEAT_PWM_FREQ2,
+		  | FEAT_PWM_FREQ2 | FEAT_SCALING | FEAT_FANCTL_ONOFF,
 				/* PECI: guesswork */
 				/* 12mV ADC (OHM) */
 				/* 16 bit fans (OHM) */
 				/* three fans, always 16 bit (guesswork) */
+		.num_temp_limit = 3,
 		.peci_mask = 0x07,
 	},
 	[it8772] = {
@@ -381,32 +488,39 @@ static const struct it87_devices it87_de
 		.suffix = "E",
 		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
 		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_IN7_INTERNAL
-		  | FEAT_PWM_FREQ2,
+		  | FEAT_PWM_FREQ2 | FEAT_SCALING | FEAT_FANCTL_ONOFF,
 				/* PECI (coreboot) */
 				/* 12mV ADC (HWSensors4, OHM) */
 				/* 16 bit fans (HWSensors4, OHM) */
 				/* three fans, always 16 bit (datasheet) */
+		.num_temp_limit = 3,
 		.peci_mask = 0x07,
 	},
 	[it8781] = {
 		.name = "it8781",
 		.suffix = "F",
 		.features = FEAT_16BIT_FANS | FEAT_TEMP_OFFSET
-		  | FEAT_TEMP_OLD_PECI | FEAT_FAN16_CONFIG | FEAT_PWM_FREQ2,
+		  | FEAT_TEMP_OLD_PECI | FEAT_FAN16_CONFIG | FEAT_PWM_FREQ2
+		  | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
 		.old_peci_mask = 0x4,
 	},
 	[it8782] = {
 		.name = "it8782",
 		.suffix = "F",
 		.features = FEAT_16BIT_FANS | FEAT_TEMP_OFFSET
-		  | FEAT_TEMP_OLD_PECI | FEAT_FAN16_CONFIG | FEAT_PWM_FREQ2,
+		  | FEAT_TEMP_OLD_PECI | FEAT_FAN16_CONFIG | FEAT_PWM_FREQ2
+		  | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
 		.old_peci_mask = 0x4,
 	},
 	[it8783] = {
 		.name = "it8783",
 		.suffix = "E/F",
 		.features = FEAT_16BIT_FANS | FEAT_TEMP_OFFSET
-		  | FEAT_TEMP_OLD_PECI | FEAT_FAN16_CONFIG | FEAT_PWM_FREQ2,
+		  | FEAT_TEMP_OLD_PECI | FEAT_FAN16_CONFIG | FEAT_PWM_FREQ2
+		  | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
 		.old_peci_mask = 0x4,
 	},
 	[it8786] = {
@@ -414,32 +528,55 @@ static const struct it87_devices it87_de
 		.suffix = "E",
 		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
 		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_IN7_INTERNAL
-		  | FEAT_PWM_FREQ2,
+		  | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
 		.peci_mask = 0x07,
 	},
 	[it8790] = {
 		.name = "it8790",
 		.suffix = "E",
-		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
-		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_IN7_INTERNAL
-		  | FEAT_PWM_FREQ2,
+		.features = FEAT_NEWER_AUTOPWM | FEAT_10_9MV_ADC | FEAT_SCALING
+		  | FEAT_16BIT_FANS | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI
+		  | FEAT_IN7_INTERNAL | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
 		.peci_mask = 0x07,
 	},
 	[it8792] = {
 		.name = "it8792",
 		.suffix = "E",
-		.features = FEAT_NEWER_AUTOPWM | FEAT_16BIT_FANS
-		  | FEAT_TEMP_OFFSET | FEAT_TEMP_OLD_PECI | FEAT_TEMP_PECI
-		  | FEAT_10_9MV_ADC | FEAT_IN7_INTERNAL,
+		.features = FEAT_NEWER_AUTOPWM | FEAT_10_9MV_ADC | FEAT_SCALING
+		  | FEAT_16BIT_FANS | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI
+		  | FEAT_IN7_INTERNAL | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
 		.peci_mask = 0x07,
-		.old_peci_mask = 0x02,	/* Actually reports PCH */
 	},
 	[it8603] = {
 		.name = "it8603",
 		.suffix = "E",
 		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
 		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_IN7_INTERNAL
-		  | FEAT_AVCC3 | FEAT_PWM_FREQ2,
+		  | FEAT_AVCC3 | FEAT_PWM_FREQ2 | FEAT_SCALING,
+		.num_temp_limit = 3,
+		.peci_mask = 0x07,
+	},
+	[it8607] = {
+		.name = "it8607",
+		.suffix = "E",
+		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
+		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_IN7_INTERNAL
+		  | FEAT_AVCC3 | FEAT_PWM_FREQ2 | FEAT_SCALING
+		  | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
+		.peci_mask = 0x07,
+	},
+	[it8613] = {
+		.name = "it8613",
+		.suffix = "E",
+		.features = FEAT_NEWER_AUTOPWM | FEAT_11MV_ADC | FEAT_16BIT_FANS
+		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_FIVE_FANS
+		  | FEAT_FIVE_PWM | FEAT_IN7_INTERNAL | FEAT_PWM_FREQ2
+		  | FEAT_AVCC3 | FEAT_SCALING | FEAT_NEW_TEMPMAP,
+		.num_temp_limit = 6,
 		.peci_mask = 0x07,
 	},
 	[it8620] = {
@@ -448,7 +585,9 @@ static const struct it87_devices it87_de
 		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
 		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_SIX_FANS
 		  | FEAT_IN7_INTERNAL | FEAT_SIX_PWM | FEAT_PWM_FREQ2
-		  | FEAT_SIX_TEMP | FEAT_VIN3_5V,
+		  | FEAT_SIX_TEMP | FEAT_VIN3_5V | FEAT_SCALING
+		  | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
 		.peci_mask = 0x07,
 	},
 	[it8622] = {
@@ -457,18 +596,56 @@ static const struct it87_devices it87_de
 		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
 		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_FIVE_FANS
 		  | FEAT_FIVE_PWM | FEAT_IN7_INTERNAL | FEAT_PWM_FREQ2
-		  | FEAT_AVCC3 | FEAT_VIN3_5V,
+		  | FEAT_AVCC3 | FEAT_VIN3_5V | FEAT_SCALING,
+		.num_temp_limit = 3,
 		.peci_mask = 0x07,
 	},
+	[it8625] = {
+		.name = "it8625",
+		.suffix = "E",
+		.features = FEAT_NEWER_AUTOPWM | FEAT_16BIT_FANS
+		  | FEAT_TEMP_OFFSET | FEAT_AVCC3 | FEAT_NEW_TEMPMAP
+		  | FEAT_11MV_ADC | FEAT_IN7_INTERNAL | FEAT_SIX_FANS
+		  | FEAT_SIX_PWM | FEAT_BANK_SEL | FEAT_SCALING,
+		.num_temp_limit = 6,
+	},
 	[it8628] = {
 		.name = "it8628",
 		.suffix = "E",
 		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
 		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_SIX_FANS
 		  | FEAT_IN7_INTERNAL | FEAT_SIX_PWM | FEAT_PWM_FREQ2
-		  | FEAT_SIX_TEMP | FEAT_VIN3_5V,
+		  | FEAT_SIX_TEMP | FEAT_SCALING | FEAT_AVCC3
+		  | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
 		.peci_mask = 0x07,
 	},
+	[it8655] = {
+		.name = "it8655",
+		.suffix = "E",
+		.features = FEAT_NEWER_AUTOPWM | FEAT_16BIT_FANS
+		  | FEAT_TEMP_OFFSET | FEAT_AVCC3 | FEAT_NEW_TEMPMAP
+		  | FEAT_10_9MV_ADC | FEAT_IN7_INTERNAL | FEAT_BANK_SEL,
+		.num_temp_limit = 6,
+	},
+	[it8665] = {
+		.name = "it8665",
+		.suffix = "E",
+		.features = FEAT_NEWER_AUTOPWM | FEAT_16BIT_FANS
+		  | FEAT_TEMP_OFFSET | FEAT_AVCC3 | FEAT_NEW_TEMPMAP
+		  | FEAT_10_9MV_ADC | FEAT_IN7_INTERNAL | FEAT_SIX_FANS
+		  | FEAT_SIX_PWM | FEAT_BANK_SEL,
+		.num_temp_limit = 6,
+	},
+	[it8686] = {
+		.name = "it8686",
+		.suffix = "E",
+		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
+		  | FEAT_TEMP_OFFSET | FEAT_SIX_FANS | FEAT_NEW_TEMPMAP
+		  | FEAT_IN7_INTERNAL | FEAT_SIX_PWM | FEAT_PWM_FREQ2
+		  | FEAT_SIX_TEMP | FEAT_BANK_SEL | FEAT_SCALING | FEAT_AVCC3,
+		.num_temp_limit = 6,
+	},
 };
 
 #define has_16bit_fans(data)	((data)->features & FEAT_16BIT_FANS)
@@ -495,6 +672,17 @@ static const struct it87_devices it87_de
 #define has_pwm_freq2(data)	((data)->features & FEAT_PWM_FREQ2)
 #define has_six_temp(data)	((data)->features & FEAT_SIX_TEMP)
 #define has_vin3_5v(data)	((data)->features & FEAT_VIN3_5V)
+#define has_four_fans(data)	((data)->features & (FEAT_FOUR_FANS | \
+						     FEAT_FIVE_FANS | \
+						     FEAT_SIX_FANS))
+#define has_four_pwm(data)	((data)->features & (FEAT_FOUR_PWM | \
+						     FEAT_FIVE_PWM \
+						     | FEAT_SIX_PWM))
+#define has_bank_sel(data)	((data)->features & FEAT_BANK_SEL)
+#define has_scaling(data)	((data)->features & FEAT_SCALING)
+#define has_fanctl_onoff(data)	((data)->features & FEAT_FANCTL_ONOFF)
+#define has_11mv_adc(data)	((data)->features & FEAT_11MV_ADC)
+#define has_new_tempmap(data)	((data)->features & FEAT_NEW_TEMPMAP)
 
 struct it87_sio_data {
 	enum chips type;
@@ -519,9 +707,21 @@ struct it87_data {
 	const struct attribute_group *groups[7];
 	enum chips type;
 	u32 features;
+	u8 bank;
 	u8 peci_mask;
 	u8 old_peci_mask;
 
+	const u8 *REG_FAN;
+	const u8 *REG_FANX;
+	const u8 *REG_FAN_MIN;
+	const u8 *REG_FANX_MIN;
+
+	const u8 *REG_PWM;
+
+	const u8 *REG_TEMP_OFFSET;
+	const u8 *REG_TEMP_LOW;
+	const u8 *REG_TEMP_HIGH;
+
 	unsigned short addr;
 	const char *name;
 	struct mutex update_lock;
@@ -536,6 +736,7 @@ struct it87_data {
 	u16 fan[NUM_FAN][2];	/* Register values, [nr][0]=fan, [1]=min */
 	u8 has_temp;		/* Bitfield, temp sensors enabled */
 	s8 temp[NUM_TEMP][4];	/* [nr][0]=temp, [1]=min, [2]=max, [3]=offset */
+	u8 num_temp_limit;	/* Number of temp limit/offset registers */
 	u8 sensor;		/* Register value (IT87_REG_TEMP_ENABLE) */
 	u8 extra;		/* Register value (IT87_REG_TEMP_EXTRA) */
 	u8 fan_div[NUM_FAN_DIV];/* Register encoding, shifted right */
@@ -576,6 +777,8 @@ static int adc_lsb(const struct it87_dat
 		lsb = 120;
 	else if (has_10_9mv_adc(data))
 		lsb = 109;
+	else if (has_11mv_adc(data))
+		lsb = 110;
 	else
 		lsb = 160;
 	if (data->in_scaled & BIT(nr))
@@ -667,15 +870,39 @@ static const unsigned int pwm_freq[8] =
 	750000,
 };
 
+static int _it87_read_value(struct it87_data *data, u8 reg)
+{
+	outb_p(reg, data->addr + IT87_ADDR_REG_OFFSET);
+	return inb_p(data->addr + IT87_DATA_REG_OFFSET);
+}
+
+static void _it87_write_value(struct it87_data *data, u8 reg, u8 value)
+{
+	outb_p(reg, data->addr + IT87_ADDR_REG_OFFSET);
+	outb_p(value, data->addr + IT87_DATA_REG_OFFSET);
+}
+
+static void it87_set_bank(struct it87_data *data, u8 bank)
+{
+	if (has_bank_sel(data) && bank != data->bank) {
+		u8 breg = _it87_read_value(data, IT87_REG_BANK);
+
+		breg &= 0x1f;
+		breg |= (bank << 5);
+		data->bank = bank;
+		_it87_write_value(data, IT87_REG_BANK, breg);
+	}
+}
+
 /*
  * Must be called with data->update_lock held, except during initialization.
  * We ignore the IT87 BUSY flag at this moment - it could lead to deadlocks,
  * would slow down the IT87 access and should not be necessary.
  */
-static int it87_read_value(struct it87_data *data, u8 reg)
+static int it87_read_value(struct it87_data *data, u16 reg)
 {
-	outb_p(reg, data->addr + IT87_ADDR_REG_OFFSET);
-	return inb_p(data->addr + IT87_DATA_REG_OFFSET);
+	it87_set_bank(data, reg >> 8);
+	return _it87_read_value(data, reg & 0xff);
 }
 
 /*
@@ -683,17 +910,20 @@ static int it87_read_value(struct it87_d
  * We ignore the IT87 BUSY flag at this moment - it could lead to deadlocks,
  * would slow down the IT87 access and should not be necessary.
  */
-static void it87_write_value(struct it87_data *data, u8 reg, u8 value)
+static void it87_write_value(struct it87_data *data, u16 reg, u8 value)
 {
-	outb_p(reg, data->addr + IT87_ADDR_REG_OFFSET);
-	outb_p(value, data->addr + IT87_DATA_REG_OFFSET);
+	it87_set_bank(data, reg >> 8);
+	_it87_write_value(data, reg & 0xff, value);
 }
 
 static void it87_update_pwm_ctrl(struct it87_data *data, int nr)
 {
-	data->pwm_ctrl[nr] = it87_read_value(data, IT87_REG_PWM[nr]);
+	data->pwm_ctrl[nr] = it87_read_value(data, data->REG_PWM[nr]);
 	if (has_newer_autopwm(data)) {
-		data->pwm_temp_map[nr] = data->pwm_ctrl[nr] & 0x03;
+		if (has_new_tempmap(data))
+			data->pwm_temp_map[nr] = data->pwm_ctrl[nr] & 0x38;
+		else
+			data->pwm_temp_map[nr] = data->pwm_ctrl[nr] & 0x03;
 		data->pwm_duty[nr] = it87_read_value(data,
 						     IT87_REG_PWM_DUTY[nr]);
 	} else {
@@ -779,15 +1009,15 @@ static struct it87_data *it87_update_dev
 				continue;
 
 			data->fan[i][1] =
-				it87_read_value(data, IT87_REG_FAN_MIN[i]);
+				it87_read_value(data, data->REG_FAN_MIN[i]);
 			data->fan[i][0] = it87_read_value(data,
-				       IT87_REG_FAN[i]);
+				       data->REG_FAN[i]);
 			/* Add high byte if in 16-bit mode */
 			if (has_16bit_fans(data)) {
 				data->fan[i][0] |= it87_read_value(data,
-						IT87_REG_FANX[i]) << 8;
+						data->REG_FANX[i]) << 8;
 				data->fan[i][1] |= it87_read_value(data,
-						IT87_REG_FANX_MIN[i]) << 8;
+						data->REG_FANX_MIN[i]) << 8;
 			}
 		}
 		for (i = 0; i < NUM_TEMP; i++) {
@@ -796,18 +1026,18 @@ static struct it87_data *it87_update_dev
 			data->temp[i][0] =
 				it87_read_value(data, IT87_REG_TEMP(i));
 
-			if (has_temp_offset(data) && i < NUM_TEMP_OFFSET)
+			if (i >= data->num_temp_limit)
+				continue;
+
+			if (has_temp_offset(data))
 				data->temp[i][3] =
 				  it87_read_value(data,
-						  IT87_REG_TEMP_OFFSET[i]);
-
-			if (i >= NUM_TEMP_LIMIT)
-				continue;
+						  data->REG_TEMP_OFFSET[i]);
 
 			data->temp[i][1] =
-				it87_read_value(data, IT87_REG_TEMP_LOW(i));
+				it87_read_value(data, data->REG_TEMP_LOW[i]);
 			data->temp[i][2] =
-				it87_read_value(data, IT87_REG_TEMP_HIGH(i));
+				it87_read_value(data, data->REG_TEMP_HIGH[i]);
 		}
 
 		/* Newer chips don't have clock dividers */
@@ -974,10 +1204,10 @@ static ssize_t set_temp(struct device *d
 	switch (index) {
 	default:
 	case 1:
-		reg = IT87_REG_TEMP_LOW(nr);
+		reg = data->REG_TEMP_LOW[nr];
 		break;
 	case 2:
-		reg = IT87_REG_TEMP_HIGH(nr);
+		reg = data->REG_TEMP_HIGH[nr];
 		break;
 	case 3:
 		regval = it87_read_value(data, IT87_REG_BEEP_ENABLE);
@@ -986,7 +1216,7 @@ static ssize_t set_temp(struct device *d
 			it87_write_value(data, IT87_REG_BEEP_ENABLE, regval);
 		}
 		data->valid = 0;
-		reg = IT87_REG_TEMP_OFFSET[nr];
+		reg = data->REG_TEMP_OFFSET[nr];
 		break;
 	}
 
@@ -1018,26 +1248,111 @@ static SENSOR_DEVICE_ATTR_2(temp3_max, S
 static SENSOR_DEVICE_ATTR_2(temp3_offset, S_IRUGO | S_IWUSR, show_temp,
 			    set_temp, 2, 3);
 static SENSOR_DEVICE_ATTR_2(temp4_input, S_IRUGO, show_temp, NULL, 3, 0);
+static SENSOR_DEVICE_ATTR_2(temp4_min, S_IRUGO | S_IWUSR, show_temp, set_temp,
+			    3, 1);
+static SENSOR_DEVICE_ATTR_2(temp4_max, S_IRUGO | S_IWUSR, show_temp, set_temp,
+			    3, 2);
+static SENSOR_DEVICE_ATTR_2(temp4_offset, S_IRUGO | S_IWUSR, show_temp,
+			    set_temp, 3, 3);
 static SENSOR_DEVICE_ATTR_2(temp5_input, S_IRUGO, show_temp, NULL, 4, 0);
+static SENSOR_DEVICE_ATTR_2(temp5_min, S_IRUGO | S_IWUSR, show_temp, set_temp,
+			    4, 1);
+static SENSOR_DEVICE_ATTR_2(temp5_max, S_IRUGO | S_IWUSR, show_temp, set_temp,
+			    4, 2);
+static SENSOR_DEVICE_ATTR_2(temp5_offset, S_IRUGO | S_IWUSR, show_temp,
+			    set_temp, 4, 3);
 static SENSOR_DEVICE_ATTR_2(temp6_input, S_IRUGO, show_temp, NULL, 5, 0);
+static SENSOR_DEVICE_ATTR_2(temp6_min, S_IRUGO | S_IWUSR, show_temp, set_temp,
+			    5, 1);
+static SENSOR_DEVICE_ATTR_2(temp6_max, S_IRUGO | S_IWUSR, show_temp, set_temp,
+			    5, 2);
+static SENSOR_DEVICE_ATTR_2(temp6_offset, S_IRUGO | S_IWUSR, show_temp,
+			    set_temp, 5, 3);
+
+static int get_temp_type(struct it87_data *data, int index)
+{
+	u8 reg, extra;
+	int type = 0;
+
+	if (has_bank_sel(data)) {
+		int s1reg = IT87_REG_TEMP_SRC1[index/2] >> ((index % 2) * 4);
+		u8 src1, src2;
+
+		src1 = (it87_read_value(data, s1reg) >> ((index % 2) * 4)) & 0x0f;
+		src2 = it87_read_value(data, IT87_REG_TEMP_SRC2);
+
+		switch (data->type) {
+		case it8686:
+			switch (src1) {
+			case 0:
+				if (index >= 3)
+					return 4;
+				break;
+			case 1:
+				if (index == 1 || index == 2 ||
+					  index == 4 || index == 5)
+					return 6;
+				break;
+			case 2:
+				if (index == 2 || index == 6)
+					return 5;
+				break;
+			default:
+				break;
+			}
+			break;
+		case it8625:
+			if (index < 3)
+				break;
+		case it8655:
+		case it8665:
+			if (src1 < 3) {
+				index = src1;
+				break;
+			}
+			switch(src1) {
+			case 3:
+				type = (src2 & BIT(index)) ? 6 : 5;
+				break;
+			case 4 ... 8:
+				type = (src2 & BIT(index)) ? 4 : 6;
+				break;
+			case 9:
+				type = (src2 & BIT(index)) ? 5 : 0;
+				break;
+			default:
+				break;
+			}
+			return type;
+		default:
+			return 0;
+		}
+	}
+	if (index >= 3)
+		return 0;
+
+	reg = it87_read_value(data, IT87_REG_TEMP_ENABLE);
+	extra = it87_read_value(data, IT87_REG_TEMP_EXTRA);
+
+	if ((has_temp_peci(data, index) && (reg >> 6 == index + 1)) ||
+	    (has_temp_old_peci(data, index) && (extra & 0x80)))
+		type = 6;		/* Intel PECI */
+	if (reg & BIT(index))
+		type = 3;		/* thermal diode */
+	else if (reg & BIT(index + 3))
+		type = 4;		/* thermistor */
+
+	return type;
+}
 
 static ssize_t show_temp_type(struct device *dev, struct device_attribute *attr,
 			      char *buf)
 {
 	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);
-	int nr = sensor_attr->index;
 	struct it87_data *data = it87_update_device(dev);
-	u8 reg = data->sensor;	    /* In case value is updated while used */
-	u8 extra = data->extra;
+	int type = get_temp_type(data, sensor_attr->index);
 
-	if ((has_temp_peci(data, nr) && (reg >> 6 == nr + 1)) ||
-	    (has_temp_old_peci(data, nr) && (extra & 0x80)))
-		return sprintf(buf, "6\n");  /* Intel PECI */
-	if (reg & (1 << nr))
-		return sprintf(buf, "3\n");  /* thermal diode */
-	if (reg & (8 << nr))
-		return sprintf(buf, "4\n");  /* thermistor */
-	return sprintf(buf, "0\n");      /* disabled */
+	return sprintf(buf, "%d\n", type);
 }
 
 static ssize_t set_temp_type(struct device *dev, struct device_attribute *attr,
@@ -1095,16 +1410,23 @@ static SENSOR_DEVICE_ATTR(temp2_type, S_
 			  set_temp_type, 1);
 static SENSOR_DEVICE_ATTR(temp3_type, S_IRUGO | S_IWUSR, show_temp_type,
 			  set_temp_type, 2);
+static SENSOR_DEVICE_ATTR(temp4_type, S_IRUGO | S_IWUSR, show_temp_type,
+			  set_temp_type, 3);
+static SENSOR_DEVICE_ATTR(temp5_type, S_IRUGO | S_IWUSR, show_temp_type,
+			  set_temp_type, 4);
+static SENSOR_DEVICE_ATTR(temp6_type, S_IRUGO | S_IWUSR, show_temp_type,
+			  set_temp_type, 5);
 
 /* 6 Fans */
 
 static int pwm_mode(const struct it87_data *data, int nr)
 {
-	if (data->type != it8603 && nr < 3 && !(data->fan_main_ctrl & BIT(nr)))
+	if (has_fanctl_onoff(data) && nr < 3 &&
+	    !(data->fan_main_ctrl & BIT(nr)))
 		return 0;				/* Full speed */
 	if (data->pwm_ctrl[nr] & 0x80)
 		return 2;				/* Automatic mode */
-	if ((data->type == it8603 || nr >= 3) &&
+	if ((!has_fanctl_onoff(data) || nr >= 3) &&
 	    data->pwm_duty[nr] == pwm_to_reg(data, 0xff))
 		return 0;			/* Full speed */
 
@@ -1195,9 +1517,9 @@ static ssize_t set_fan(struct device *de
 
 	if (has_16bit_fans(data)) {
 		data->fan[nr][index] = FAN16_TO_REG(val);
-		it87_write_value(data, IT87_REG_FAN_MIN[nr],
+		it87_write_value(data, data->REG_FAN_MIN[nr],
 				 data->fan[nr][index] & 0xff);
-		it87_write_value(data, IT87_REG_FANX_MIN[nr],
+		it87_write_value(data, data->REG_FANX_MIN[nr],
 				 data->fan[nr][index] >> 8);
 	} else {
 		reg = it87_read_value(data, IT87_REG_FAN_DIV);
@@ -1214,7 +1536,7 @@ static ssize_t set_fan(struct device *de
 		}
 		data->fan[nr][index] =
 		  FAN_TO_REG(val, DIV_FROM_REG(data->fan_div[nr]));
-		it87_write_value(data, IT87_REG_FAN_MIN[nr],
+		it87_write_value(data, data->REG_FAN_MIN[nr],
 				 data->fan[nr][index]);
 	}
 
@@ -1261,7 +1583,7 @@ static ssize_t set_fan_div(struct device
 
 	/* Restore fan min limit */
 	data->fan[nr][1] = FAN_TO_REG(min, DIV_FROM_REG(data->fan_div[nr]));
-	it87_write_value(data, IT87_REG_FAN_MIN[nr], data->fan[nr][1]);
+	it87_write_value(data, data->REG_FAN_MIN[nr], data->fan[nr][1]);
 
 	mutex_unlock(&data->update_lock);
 	return count;
@@ -1317,7 +1639,7 @@ static ssize_t set_pwm_enable(struct dev
 	mutex_lock(&data->update_lock);
 
 	if (val == 0) {
-		if (nr < 3 && data->type != it8603) {
+		if (nr < 3 && has_fanctl_onoff(data)) {
 			int tmp;
 			/* make sure the fan is on when in on/off mode */
 			tmp = it87_read_value(data, IT87_REG_FAN_CTL);
@@ -1341,7 +1663,7 @@ static ssize_t set_pwm_enable(struct dev
 				ctrl = data->pwm_duty[nr];
 			}
 			data->pwm_ctrl[nr] = ctrl;
-			it87_write_value(data, IT87_REG_PWM[nr], ctrl);
+			it87_write_value(data, data->REG_PWM[nr], ctrl);
 		}
 	} else {
 		u8 ctrl;
@@ -1355,9 +1677,9 @@ static ssize_t set_pwm_enable(struct dev
 			ctrl = (val == 1 ? data->pwm_duty[nr] : 0x80);
 		}
 		data->pwm_ctrl[nr] = ctrl;
-		it87_write_value(data, IT87_REG_PWM[nr], ctrl);
+		it87_write_value(data, data->REG_PWM[nr], ctrl);
 
-		if (data->type != it8603 && nr < 3) {
+		if (has_fanctl_onoff(data) && nr < 3) {
 			/* set SmartGuardian mode */
 			data->fan_main_ctrl |= BIT(nr);
 			it87_write_value(data, IT87_REG_FAN_MAIN_CTRL,
@@ -1402,7 +1724,7 @@ static ssize_t set_pwm(struct device *de
 		 */
 		if (!(data->pwm_ctrl[nr] & 0x80)) {
 			data->pwm_ctrl[nr] = data->pwm_duty[nr];
-			it87_write_value(data, IT87_REG_PWM[nr],
+			it87_write_value(data, data->REG_PWM[nr],
 					 data->pwm_ctrl[nr]);
 		}
 	}
@@ -1455,10 +1777,16 @@ static ssize_t show_pwm_temp_map(struct
 	int map;
 
 	map = data->pwm_temp_map[nr];
-	if (map >= 3)
-		map = 0;	/* Should never happen */
-	if (nr >= 3)		/* pwm channels 3..6 map to temp4..6 */
-		map += 3;
+	if (has_new_tempmap(data)) {
+		map >>= 3;
+		if (map >= 6)
+			map = 0;	/* Should never happen */
+	} else {
+		if (map >= 3)
+			map = 0;	/* Should never happen */
+		if (nr >= 3)		/* pwm channels 3..6 map to temp4..6 */
+			map += 3;
+	}
 
 	return sprintf(buf, "%d\n", (int)BIT(map));
 }
@@ -1476,7 +1804,7 @@ static ssize_t set_pwm_temp_map(struct d
 	if (kstrtol(buf, 10, &val) < 0)
 		return -EINVAL;
 
-	if (nr >= 3)
+	if (nr >= 3 && !has_new_tempmap(data))
 		val -= 3;
 
 	switch (val) {
@@ -1489,10 +1817,27 @@ static ssize_t set_pwm_temp_map(struct d
 	case BIT(2):
 		reg = 0x02;
 		break;
+	case BIT(3):
+		reg = 0x03;
+		break;
+	case BIT(4):
+		reg = 0x04;
+		break;
+	case BIT(5):
+		reg = 0x05;
+		break;
+	case BIT(6):
+		reg = 0x06;
+		break;
 	default:
 		return -EINVAL;
 	}
 
+	if (has_new_tempmap(data))
+		reg <<= 3;
+	else if (reg > 0x02)
+		return -EINVAL;
+
 	mutex_lock(&data->update_lock);
 	it87_update_pwm_ctrl(data, nr);
 	data->pwm_temp_map[nr] = reg;
@@ -1501,9 +1846,11 @@ static ssize_t set_pwm_temp_map(struct d
 	 * otherwise, just store it for later use.
 	 */
 	if (data->pwm_ctrl[nr] & 0x80) {
-		data->pwm_ctrl[nr] = (data->pwm_ctrl[nr] & 0xfc) |
+		u8 mask = has_new_tempmap(data) ? 0xc7 : 0xfc;
+
+		data->pwm_ctrl[nr] = (data->pwm_ctrl[nr] & mask) |
 						data->pwm_temp_map[nr];
-		it87_write_value(data, IT87_REG_PWM[nr], data->pwm_ctrl[nr]);
+		it87_write_value(data, data->REG_PWM[nr], data->pwm_ctrl[nr]);
 	}
 	mutex_unlock(&data->update_lock);
 	return count;
@@ -1802,14 +2149,14 @@ static SENSOR_DEVICE_ATTR(pwm6_auto_slop
 			  show_auto_pwm_slope, set_auto_pwm_slope, 5);
 
 /* Alarms */
-static ssize_t alarms_show(struct device *dev, struct device_attribute *attr,
+static ssize_t show_alarms(struct device *dev, struct device_attribute *attr,
 			   char *buf)
 {
 	struct it87_data *data = it87_update_device(dev);
 
 	return sprintf(buf, "%u\n", data->alarms);
 }
-static DEVICE_ATTR_RO(alarms);
+static DEVICE_ATTR(alarms, S_IRUGO, show_alarms, NULL);
 
 static ssize_t show_alarm(struct device *dev, struct device_attribute *attr,
 			  char *buf)
@@ -1863,6 +2210,9 @@ static SENSOR_DEVICE_ATTR(fan6_alarm, S_
 static SENSOR_DEVICE_ATTR(temp1_alarm, S_IRUGO, show_alarm, NULL, 16);
 static SENSOR_DEVICE_ATTR(temp2_alarm, S_IRUGO, show_alarm, NULL, 17);
 static SENSOR_DEVICE_ATTR(temp3_alarm, S_IRUGO, show_alarm, NULL, 18);
+static SENSOR_DEVICE_ATTR(temp4_alarm, S_IRUGO, show_alarm, NULL, 19);
+static SENSOR_DEVICE_ATTR(temp5_alarm, S_IRUGO, show_alarm, NULL, 20);
+static SENSOR_DEVICE_ATTR(temp6_alarm, S_IRUGO, show_alarm, NULL, 21);
 static SENSOR_DEVICE_ATTR(intrusion0_alarm, S_IRUGO | S_IWUSR,
 			  show_alarm, clear_intrusion, 4);
 
@@ -1916,17 +2266,20 @@ static SENSOR_DEVICE_ATTR(temp1_beep, S_
 			  show_beep, set_beep, 2);
 static SENSOR_DEVICE_ATTR(temp2_beep, S_IRUGO, show_beep, NULL, 2);
 static SENSOR_DEVICE_ATTR(temp3_beep, S_IRUGO, show_beep, NULL, 2);
+static SENSOR_DEVICE_ATTR(temp4_beep, S_IRUGO, show_beep, NULL, 2);
+static SENSOR_DEVICE_ATTR(temp5_beep, S_IRUGO, show_beep, NULL, 2);
+static SENSOR_DEVICE_ATTR(temp6_beep, S_IRUGO, show_beep, NULL, 2);
 
-static ssize_t vrm_show(struct device *dev, struct device_attribute *attr,
-			char *buf)
+static ssize_t show_vrm_reg(struct device *dev, struct device_attribute *attr,
+			    char *buf)
 {
 	struct it87_data *data = dev_get_drvdata(dev);
 
 	return sprintf(buf, "%u\n", data->vrm);
 }
 
-static ssize_t vrm_store(struct device *dev, struct device_attribute *attr,
-			 const char *buf, size_t count)
+static ssize_t store_vrm_reg(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t count)
 {
 	struct it87_data *data = dev_get_drvdata(dev);
 	unsigned long val;
@@ -1938,16 +2291,16 @@ static ssize_t vrm_store(struct device *
 
 	return count;
 }
-static DEVICE_ATTR_RW(vrm);
+static DEVICE_ATTR(vrm, S_IRUGO | S_IWUSR, show_vrm_reg, store_vrm_reg);
 
-static ssize_t cpu0_vid_show(struct device *dev,
-			     struct device_attribute *attr, char *buf)
+static ssize_t show_vid_reg(struct device *dev, struct device_attribute *attr,
+			    char *buf)
 {
 	struct it87_data *data = it87_update_device(dev);
 
 	return sprintf(buf, "%ld\n", (long)vid_from_reg(data->vid, data->vrm));
 }
-static DEVICE_ATTR_RO(cpu0_vid);
+static DEVICE_ATTR(cpu0_vid, S_IRUGO, show_vid_reg, NULL);
 
 static ssize_t show_label(struct device *dev, struct device_attribute *attr,
 			  char *buf)
@@ -1970,7 +2323,8 @@ static ssize_t show_label(struct device
 
 	if (has_vin3_5v(data) && nr == 0)
 		label = labels[0];
-	else if (has_12mv_adc(data) || has_10_9mv_adc(data))
+	else if (has_12mv_adc(data) || has_10_9mv_adc(data) ||
+		 has_11mv_adc(data))
 		label = labels_it8721[nr];
 	else
 		label = labels[nr];
@@ -2055,10 +2409,10 @@ static struct attribute *it87_attributes
 	&sensor_dev_attr_in7_beep.dev_attr.attr,	/* 39 */
 
 	&sensor_dev_attr_in8_input.dev_attr.attr,	/* 40 */
-	&sensor_dev_attr_in9_input.dev_attr.attr,
-	&sensor_dev_attr_in10_input.dev_attr.attr,
-	&sensor_dev_attr_in11_input.dev_attr.attr,
-	&sensor_dev_attr_in12_input.dev_attr.attr,
+	&sensor_dev_attr_in9_input.dev_attr.attr,	/* 41 */
+	&sensor_dev_attr_in10_input.dev_attr.attr,	/* 42 */
+	&sensor_dev_attr_in11_input.dev_attr.attr,	/* 43 */
+	&sensor_dev_attr_in12_input.dev_attr.attr,	/* 44 */
 	NULL
 };
 
@@ -2075,14 +2429,22 @@ static umode_t it87_temp_is_visible(stru
 	int i = index / 7;	/* temperature index */
 	int a = index % 7;	/* attribute index */
 
-	if (index >= 21) {
-		i = index - 21 + 3;
-		a = 0;
-	}
-
 	if (!(data->has_temp & BIT(i)))
 		return 0;
 
+	if (a && i >= data->num_temp_limit)
+		return 0;
+
+	if (a == 3) {
+		int type = get_temp_type(data, i);
+
+		if (type == 0)
+			return 0;
+		if (has_bank_sel(data))
+			return 0444;
+		return attr->mode;
+	}
+
 	if (a == 5 && !has_temp_offset(data))
 		return 0;
 
@@ -2096,7 +2458,7 @@ static struct attribute *it87_attributes
 	&sensor_dev_attr_temp1_input.dev_attr.attr,
 	&sensor_dev_attr_temp1_max.dev_attr.attr,
 	&sensor_dev_attr_temp1_min.dev_attr.attr,
-	&sensor_dev_attr_temp1_type.dev_attr.attr,
+	&sensor_dev_attr_temp1_type.dev_attr.attr,	/* 3 */
 	&sensor_dev_attr_temp1_alarm.dev_attr.attr,
 	&sensor_dev_attr_temp1_offset.dev_attr.attr,	/* 5 */
 	&sensor_dev_attr_temp1_beep.dev_attr.attr,	/* 6 */
@@ -2118,8 +2480,28 @@ static struct attribute *it87_attributes
 	&sensor_dev_attr_temp3_beep.dev_attr.attr,
 
 	&sensor_dev_attr_temp4_input.dev_attr.attr,	/* 21 */
+	&sensor_dev_attr_temp4_max.dev_attr.attr,
+	&sensor_dev_attr_temp4_min.dev_attr.attr,
+	&sensor_dev_attr_temp4_type.dev_attr.attr,
+	&sensor_dev_attr_temp4_alarm.dev_attr.attr,
+	&sensor_dev_attr_temp4_offset.dev_attr.attr,
+	&sensor_dev_attr_temp4_beep.dev_attr.attr,
+
 	&sensor_dev_attr_temp5_input.dev_attr.attr,
+	&sensor_dev_attr_temp5_max.dev_attr.attr,
+	&sensor_dev_attr_temp5_min.dev_attr.attr,
+	&sensor_dev_attr_temp5_type.dev_attr.attr,
+	&sensor_dev_attr_temp5_alarm.dev_attr.attr,
+	&sensor_dev_attr_temp5_offset.dev_attr.attr,
+	&sensor_dev_attr_temp5_beep.dev_attr.attr,
+
 	&sensor_dev_attr_temp6_input.dev_attr.attr,
+	&sensor_dev_attr_temp6_max.dev_attr.attr,
+	&sensor_dev_attr_temp6_min.dev_attr.attr,
+	&sensor_dev_attr_temp6_type.dev_attr.attr,
+	&sensor_dev_attr_temp6_alarm.dev_attr.attr,
+	&sensor_dev_attr_temp6_offset.dev_attr.attr,
+	&sensor_dev_attr_temp6_beep.dev_attr.attr,
 	NULL
 };
 
@@ -2394,7 +2776,6 @@ static int __init it87_find(int sioaddr,
 {
 	int err;
 	u16 chip_type;
-	const char *board_vendor, *board_name;
 	const struct it87_devices *config;
 
 	err = superio_enter(sioaddr);
@@ -2402,7 +2783,12 @@ static int __init it87_find(int sioaddr,
 		return err;
 
 	err = -ENODEV;
-	chip_type = force_id ? force_id : superio_inw(sioaddr, DEVID);
+	chip_type = superio_inw(sioaddr, DEVID);
+	if (chip_type == 0xffff)
+		goto exit;
+
+	if (force_id)
+		chip_type = force_id;
 
 	switch (chip_type) {
 	case IT8705F_DEVID:
@@ -2458,15 +2844,33 @@ static int __init it87_find(int sioaddr,
 	case IT8623E_DEVID:
 		sio_data->type = it8603;
 		break;
+	case IT8607E_DEVID:
+		sio_data->type = it8607;
+		break;
+	case IT8613E_DEVID:
+		sio_data->type = it8613;
+		break;
 	case IT8620E_DEVID:
 		sio_data->type = it8620;
 		break;
 	case IT8622E_DEVID:
 		sio_data->type = it8622;
 		break;
+	case IT8625E_DEVID:
+		sio_data->type = it8625;
+		break;
 	case IT8628E_DEVID:
 		sio_data->type = it8628;
 		break;
+	case IT8655E_DEVID:
+		sio_data->type = it8655;
+		break;
+	case IT8665E_DEVID:
+		sio_data->type = it8665;
+		break;
+	case IT8686E_DEVID:
+		sio_data->type = it8686;
+		break;
 	case 0xffff:	/* No device at all */
 		goto exit;
 	default:
@@ -2507,8 +2911,10 @@ static int __init it87_find(int sioaddr,
 	else
 		sio_data->skip_in |= BIT(9);
 
-	if (!has_five_pwm(config))
+	if (!has_four_pwm(config))
 		sio_data->skip_pwm |= BIT(3) | BIT(4) | BIT(5);
+	else if (!has_five_pwm(config))
+		sio_data->skip_pwm |= BIT(4) | BIT(5);
 	else if (!has_six_pwm(config))
 		sio_data->skip_pwm |= BIT(5);
 
@@ -2588,7 +2994,7 @@ static int __init it87_find(int sioaddr,
 
 		sio_data->beep_pin = superio_inb(sioaddr,
 						 IT87_SIO_BEEP_PIN_REG) & 0x3f;
-	} else if (sio_data->type == it8603) {
+	} else if (sio_data->type == it8603 || sio_data->type == it8607) {
 		int reg27, reg29;
 
 		superio_select(sioaddr, GPIO);
@@ -2608,12 +3014,52 @@ static int __init it87_find(int sioaddr,
 		if (reg29 & BIT(2))
 			sio_data->skip_fan |= BIT(1);
 
-		sio_data->skip_in |= BIT(5); /* No VIN5 */
-		sio_data->skip_in |= BIT(6); /* No VIN6 */
+		if (sio_data->type == it8603) {
+			sio_data->skip_in |= BIT(5); /* No VIN5 */
+			sio_data->skip_in |= BIT(6); /* No VIN6 */
+		}
 
 		sio_data->beep_pin = superio_inb(sioaddr,
 						 IT87_SIO_BEEP_PIN_REG) & 0x3f;
-	} else if (sio_data->type == it8620 || sio_data->type == it8628) {
+	} else if (sio_data->type == it8613) {
+		int reg27, reg29, reg2a;
+
+		superio_select(sioaddr, GPIO);
+
+		/* Check for pwm3, fan3, pwm5, fan5 */
+		reg27 = superio_inb(sioaddr, IT87_SIO_GPIO3_REG);
+		if (reg27 & BIT(1))
+			sio_data->skip_fan |= BIT(4);
+		if (reg27 & BIT(3))
+			sio_data->skip_pwm |= BIT(4);
+		if (reg27 & BIT(6))
+			sio_data->skip_pwm |= BIT(2);
+		if (reg27 & BIT(7))
+			sio_data->skip_fan |= BIT(2);
+
+		/* Check for pwm2, fan2 */
+		reg29 = superio_inb(sioaddr, IT87_SIO_GPIO5_REG);
+		if (reg29 & BIT(1))
+			sio_data->skip_pwm |= BIT(1);
+		if (reg29 & BIT(2))
+			sio_data->skip_fan |= BIT(1);
+
+		/* Check for pwm4, fan4 */
+		reg2a = superio_inb(sioaddr, IT87_SIO_PINX1_REG);
+		if (!(reg2a & BIT(0)) || (reg29 & BIT(7))) {
+			sio_data->skip_fan |= BIT(3);
+			sio_data->skip_pwm |= BIT(3);
+		}
+
+		sio_data->skip_pwm |= BIT(0); /* No pwm1 */
+		sio_data->skip_fan |= BIT(0); /* No fan1 */
+		sio_data->skip_in |= BIT(3);  /* No VIN3 */
+		sio_data->skip_in |= BIT(6);  /* No VIN6 */
+
+		sio_data->beep_pin = superio_inb(sioaddr,
+						 IT87_SIO_BEEP_PIN_REG) & 0x3f;
+	} else if (sio_data->type == it8620 || sio_data->type == it8628 ||
+		   sio_data->type == it8686) {
 		int reg;
 
 		superio_select(sioaddr, GPIO);
@@ -2656,10 +3102,14 @@ static int __init it87_find(int sioaddr,
 
 		/* Check if AVCC is on VIN3 */
 		reg = superio_inb(sioaddr, IT87_SIO_PINX2_REG);
-		if (reg & BIT(0))
-			sio_data->internal |= BIT(0);
-		else
+		if (reg & BIT(0)) {
+			/* For it8686, the bit just enables AVCC3 */
+			if (sio_data->type != it8686)
+				sio_data->internal |= BIT(0);
+		} else {
+			sio_data->internal &= ~BIT(3);
 			sio_data->skip_in |= BIT(9);
+		}
 
 		sio_data->beep_pin = superio_inb(sioaddr,
 						 IT87_SIO_BEEP_PIN_REG) & 0x3f;
@@ -2700,6 +3150,113 @@ static int __init it87_find(int sioaddr,
 
 		sio_data->beep_pin = superio_inb(sioaddr,
 						 IT87_SIO_BEEP_PIN_REG) & 0x3f;
+	} else if (sio_data->type == it8732) {
+		int reg;
+
+		superio_select(sioaddr, GPIO);
+
+		/* Check for pwm2, fan2 */
+		reg = superio_inb(sioaddr, IT87_SIO_GPIO5_REG);
+		if (reg & BIT(1))
+			sio_data->skip_pwm |= BIT(1);
+		if (reg & BIT(2))
+			sio_data->skip_fan |= BIT(1);
+
+		/* Check for pwm3, fan3, fan4 */
+		reg = superio_inb(sioaddr, IT87_SIO_GPIO3_REG);
+		if (reg & BIT(6))
+			sio_data->skip_pwm |= BIT(2);
+		if (reg & BIT(7))
+			sio_data->skip_fan |= BIT(2);
+		if (reg & BIT(5))
+			sio_data->skip_fan |= BIT(3);
+
+		/* Check if AVCC is on VIN3 */
+		reg = superio_inb(sioaddr, IT87_SIO_PINX2_REG);
+		if (reg & BIT(0))
+			sio_data->internal |= BIT(0);
+
+		sio_data->beep_pin = superio_inb(sioaddr,
+						 IT87_SIO_BEEP_PIN_REG) & 0x3f;
+	} else if (sio_data->type == it8655) {
+		int reg;
+
+		superio_select(sioaddr, GPIO);
+
+		/* Check for pwm2 */
+		reg = superio_inb(sioaddr, IT87_SIO_GPIO5_REG);
+		if (reg & BIT(1))
+			sio_data->skip_pwm |= BIT(1);
+
+		/* Check for fan2 */
+		reg = superio_inb(sioaddr, IT87_SIO_PINX4_REG);
+		if (reg & BIT(4))
+			sio_data->skip_fan |= BIT(1);
+
+		/* Check for pwm3, fan3 */
+		reg = superio_inb(sioaddr, IT87_SIO_GPIO3_REG);
+		if (reg & BIT(6))
+			sio_data->skip_pwm |= BIT(2);
+		if (reg & BIT(7))
+			sio_data->skip_fan |= BIT(2);
+
+		sio_data->beep_pin = superio_inb(sioaddr,
+						 IT87_SIO_BEEP_PIN_REG) & 0x3f;
+	} else if (sio_data->type == it8665 || sio_data->type == it8625) {
+		int reg27, reg29, reg2d, regd3;
+
+		superio_select(sioaddr, GPIO);
+
+		reg27 = superio_inb(sioaddr, IT87_SIO_GPIO3_REG);
+		reg29 = superio_inb(sioaddr, IT87_SIO_GPIO5_REG);
+		reg2d = superio_inb(sioaddr, IT87_SIO_PINX4_REG);
+		regd3 = superio_inb(sioaddr, IT87_SIO_GPIO9_REG);
+
+		/* Check for pwm2, fan2 */
+		if (reg29 & BIT(1))
+			sio_data->skip_pwm |= BIT(1);
+		if (reg2d & BIT(4))
+			sio_data->skip_fan |= BIT(1);
+
+		/* Check for pwm3, fan3 */
+		if (reg27 & BIT(6))
+			sio_data->skip_pwm |= BIT(2);
+		if (reg27 & BIT(7))
+			sio_data->skip_fan |= BIT(2);
+
+		/* Check for pwm4, fan4, pwm5, fan5 */
+		if (sio_data->type == it8625) {
+			int reg25 = superio_inb(sioaddr, IT87_SIO_GPIO1_REG);
+
+			if (reg25 & BIT(6))
+				sio_data->skip_fan |= BIT(3);
+			if (reg25 & BIT(5))
+				sio_data->skip_pwm |= BIT(3);
+			if (reg27 & BIT(3))
+				sio_data->skip_pwm |= BIT(4);
+			if (reg27 & BIT(1))
+				sio_data->skip_fan |= BIT(4);
+		} else {
+			int reg26 = superio_inb(sioaddr, IT87_SIO_GPIO2_REG);
+
+			if (regd3 & BIT(2))
+				sio_data->skip_pwm |= BIT(3);
+			if (regd3 & BIT(3))
+				sio_data->skip_fan |= BIT(3);
+			if (reg26 & BIT(5))
+				sio_data->skip_pwm |= BIT(4);
+			if (!(reg26 & BIT(4)))
+				sio_data->skip_fan |= BIT(4);
+		}
+
+		/* Check for pwm6, fan6 */
+		if (regd3 & BIT(0))
+			sio_data->skip_pwm |= BIT(5);
+		if (regd3 & BIT(1))
+			sio_data->skip_fan |= BIT(5);
+
+		sio_data->beep_pin = superio_inb(sioaddr,
+						 IT87_SIO_BEEP_PIN_REG) & 0x3f;
 	} else {
 		int reg;
 		bool uart6;
@@ -2804,30 +3361,70 @@ static int __init it87_find(int sioaddr,
 	if (sio_data->beep_pin)
 		pr_info("Beeping is supported\n");
 
-	/* Disable specific features based on DMI strings */
-	board_vendor = dmi_get_system_info(DMI_BOARD_VENDOR);
-	board_name = dmi_get_system_info(DMI_BOARD_NAME);
-	if (board_vendor && board_name) {
-		if (strcmp(board_vendor, "nVIDIA") == 0 &&
-		    strcmp(board_name, "FN68PT") == 0) {
-			/*
-			 * On the Shuttle SN68PT, FAN_CTL2 is apparently not
-			 * connected to a fan, but to something else. One user
-			 * has reported instant system power-off when changing
-			 * the PWM2 duty cycle, so we disable it.
-			 * I use the board name string as the trigger in case
-			 * the same board is ever used in other systems.
-			 */
-			pr_info("Disabling pwm2 due to hardware constraints\n");
-			sio_data->skip_pwm = BIT(1);
-		}
-	}
-
 exit:
 	superio_exit(sioaddr);
 	return err;
 }
 
+/* Initialize chip specific register pointers */
+static void it87_init_regs(struct it87_data *data)
+{
+	switch (data->type) {
+	case it8686:
+		data->REG_FAN = IT87_REG_FAN;
+		data->REG_FANX = IT87_REG_FANX;
+		data->REG_FAN_MIN = IT87_REG_FAN_MIN;
+		data->REG_FANX_MIN = IT87_REG_FANX_MIN;
+		data->REG_PWM = IT87_REG_PWM;
+		data->REG_TEMP_OFFSET = IT87_REG_TEMP_OFFSET_8686;
+		data->REG_TEMP_LOW = IT87_REG_TEMP_LOW_8686;
+		data->REG_TEMP_HIGH = IT87_REG_TEMP_HIGH_8686;
+		break;
+	case it8625:
+	case it8655:
+	case it8665:
+		data->REG_FAN = IT87_REG_FAN_8665;
+		data->REG_FANX = IT87_REG_FANX_8665;
+		data->REG_FAN_MIN = IT87_REG_FAN_MIN_8665;
+		data->REG_FANX_MIN = IT87_REG_FANX_MIN_8665;
+		data->REG_PWM = IT87_REG_PWM_8665;
+		data->REG_TEMP_OFFSET = IT87_REG_TEMP_OFFSET;
+		data->REG_TEMP_LOW = IT87_REG_TEMP_LOW;
+		data->REG_TEMP_HIGH = IT87_REG_TEMP_HIGH;
+		break;
+	case it8622:
+		data->REG_FAN = IT87_REG_FAN;
+		data->REG_FANX = IT87_REG_FANX;
+		data->REG_FAN_MIN = IT87_REG_FAN_MIN;
+		data->REG_FANX_MIN = IT87_REG_FANX_MIN;
+		data->REG_PWM = IT87_REG_PWM_8665;
+		data->REG_TEMP_OFFSET = IT87_REG_TEMP_OFFSET;
+		data->REG_TEMP_LOW = IT87_REG_TEMP_LOW;
+		data->REG_TEMP_HIGH = IT87_REG_TEMP_HIGH;
+		break;
+	case it8613:
+		data->REG_FAN = IT87_REG_FAN;
+		data->REG_FANX = IT87_REG_FANX;
+		data->REG_FAN_MIN = IT87_REG_FAN_MIN;
+		data->REG_FANX_MIN = IT87_REG_FANX_MIN;
+		data->REG_PWM = IT87_REG_PWM_8665;
+		data->REG_TEMP_OFFSET = IT87_REG_TEMP_OFFSET;
+		data->REG_TEMP_LOW = IT87_REG_TEMP_LOW;
+		data->REG_TEMP_HIGH = IT87_REG_TEMP_HIGH;
+		break;
+	default:
+		data->REG_FAN = IT87_REG_FAN;
+		data->REG_FANX = IT87_REG_FANX;
+		data->REG_FAN_MIN = IT87_REG_FAN_MIN;
+		data->REG_FANX_MIN = IT87_REG_FANX_MIN;
+		data->REG_PWM = IT87_REG_PWM;
+		data->REG_TEMP_OFFSET = IT87_REG_TEMP_OFFSET;
+		data->REG_TEMP_LOW = IT87_REG_TEMP_LOW;
+		data->REG_TEMP_HIGH = IT87_REG_TEMP_HIGH;
+		break;
+	}
+}
+
 /* Called when we have found a new IT87. */
 static void it87_init_device(struct platform_device *pdev)
 {
@@ -2867,10 +3464,10 @@ static void it87_init_device(struct plat
 		if (tmp == 0xff)
 			it87_write_value(data, IT87_REG_VIN_MIN(i), 0);
 	}
-	for (i = 0; i < NUM_TEMP_LIMIT; i++) {
-		tmp = it87_read_value(data, IT87_REG_TEMP_HIGH(i));
+	for (i = 0; i < data->num_temp_limit; i++) {
+		tmp = it87_read_value(data, data->REG_TEMP_HIGH[i]);
 		if (tmp == 0xff)
-			it87_write_value(data, IT87_REG_TEMP_HIGH(i), 127);
+			it87_write_value(data, data->REG_TEMP_HIGH[i], 127);
 	}
 
 	/*
@@ -2911,26 +3508,44 @@ static void it87_init_device(struct plat
 	}
 
 	/* Check for additional fans */
-	if (has_five_fans(data)) {
-		if (tmp & BIT(4))
-			data->has_fan |= BIT(3); /* fan4 enabled */
-		if (tmp & BIT(5))
-			data->has_fan |= BIT(4); /* fan5 enabled */
-		if (has_six_fans(data) && (tmp & BIT(2)))
-			data->has_fan |= BIT(5); /* fan6 enabled */
+	if (has_four_fans(data) && (tmp & BIT(4)))
+		data->has_fan |= BIT(3); /* fan4 enabled */
+	if (has_five_fans(data) && (tmp & BIT(5)))
+		data->has_fan |= BIT(4); /* fan5 enabled */
+	if (has_six_fans(data)) {
+		switch (data->type) {
+		case it8620:
+		case it8628:
+		case it8686:
+			if (tmp & BIT(2))
+				data->has_fan |= BIT(5); /* fan6 enabled */
+			break;
+		case it8625:
+		case it8665:
+			tmp = it87_read_value(data, IT87_REG_FAN_DIV);
+			if (tmp & BIT(3))
+				data->has_fan |= BIT(5); /* fan6 enabled */
+			break;
+		default:
+			break;
+		}
 	}
 
 	/* Fan input pins may be used for alternative functions */
 	data->has_fan &= ~sio_data->skip_fan;
 
-	/* Check if pwm5, pwm6 are enabled */
+	/* Check if pwm6 is enabled */
 	if (has_six_pwm(data)) {
-		/* The following code may be IT8620E specific */
-		tmp = it87_read_value(data, IT87_REG_FAN_DIV);
-		if ((tmp & 0xc0) == 0xc0)
-			sio_data->skip_pwm |= BIT(4);
-		if (!(tmp & BIT(3)))
-			sio_data->skip_pwm |= BIT(5);
+		switch (data->type) {
+		case it8620:
+		case it8686:
+			tmp = it87_read_value(data, IT87_REG_FAN_DIV);
+			if (!(tmp & BIT(3)))
+				sio_data->skip_pwm |= BIT(5);
+			break;
+		default:
+			break;
+		}
 	}
 
 	/* Start monitoring */
@@ -2959,39 +3574,33 @@ static int it87_check_pwm(struct device
 			 */
 			int i;
 			u8 pwm[3];
+			u8 mode = 0;
 
 			for (i = 0; i < ARRAY_SIZE(pwm); i++)
-				pwm[i] = it87_read_value(data,
-							 IT87_REG_PWM[i]);
-
+				mode |= (pwm[i] = it87_read_value(data, data->REG_PWM[i]));
 			/*
 			 * If any fan is in automatic pwm mode, the polarity
 			 * might be correct, as suspicious as it seems, so we
 			 * better don't change anything (but still disable the
 			 * PWM interface).
 			 */
-			if (!((pwm[0] | pwm[1] | pwm[2]) & 0x80)) {
-				dev_info(dev,
-					 "Reconfiguring PWM to active high polarity\n");
-				it87_write_value(data, IT87_REG_FAN_CTL,
-						 tmp | 0x87);
-				for (i = 0; i < 3; i++)
-					it87_write_value(data,
-							 IT87_REG_PWM[i],
-							 0x7f & ~pwm[i]);
+			if (!(mode & 0x80)) {
+				dev_info(dev, "Reconfiguring PWM to active high polarity\n");
+
+				it87_write_value(data, IT87_REG_FAN_CTL, tmp | 0x87);
+
+				for (i = 0; ARRAY_SIZE(pwm); i++)
+					it87_write_value(data, data->REG_PWM[i], 0x7f & ~pwm[i]);
 				return 1;
 			}
+			dev_info(dev, "PWM configuration is too broken to be fixed\n");
 
-			dev_info(dev,
-				 "PWM configuration is too broken to be fixed\n");
 		}
-
-		dev_info(dev,
-			 "Detected broken BIOS defaults, disabling PWM interface\n");
+		dev_info(dev, "Detected broken BIOS defaults, disabling PWM interface\n");
 		return 0;
+
 	} else if (fix_pwm_polarity) {
-		dev_info(dev,
-			 "PWM configuration looks sane, won't touch\n");
+		dev_info(dev, "PWM configuration looks sane, won't touch\n");
 	}
 
 	return 1;
@@ -3022,8 +3631,11 @@ static int it87_probe(struct platform_de
 	data->addr = res->start;
 	data->type = sio_data->type;
 	data->features = it87_devices[sio_data->type].features;
+	data->num_temp_limit = it87_devices[sio_data->type].num_temp_limit;
 	data->peci_mask = it87_devices[sio_data->type].peci_mask;
 	data->old_peci_mask = it87_devices[sio_data->type].old_peci_mask;
+	data->bank = 0xff;
+
 	/*
 	 * IT8705F Datasheet 0.4.1, 3h == Version G.
 	 * IT8712F Datasheet 0.9.1, section 8.3.5 indicates 8h == Version J.
@@ -3056,11 +3668,14 @@ static int it87_probe(struct platform_de
 
 	mutex_init(&data->update_lock);
 
+	/* Initialize register pointers */
+	it87_init_regs(data);
+
 	/* Check PWM configuration */
 	enable_pwm_interface = it87_check_pwm(dev);
 
 	/* Starting with IT8721F, we handle scaling of internal voltages */
-	if (has_12mv_adc(data)) {
+	if (has_scaling(data)) {
 		if (sio_data->internal & BIT(0))
 			data->in_scaled |= BIT(3);	/* in3 is AVCC */
 		if (sio_data->internal & BIT(1))
@@ -3173,8 +3788,7 @@ static int __init it87_device_add(int in
 		goto exit_device_put;
 	}
 
-	err = platform_device_add_data(pdev, sio_data,
-				       sizeof(struct it87_sio_data));
+	err = platform_device_add_data(pdev, sio_data, sizeof(struct it87_sio_data));
 	if (err) {
 		pr_err("Platform data allocation failed\n");
 		goto exit_device_put;
@@ -3194,43 +3808,170 @@ exit_device_put:
 	return err;
 }
 
+struct it87_dmi_data {
+	bool sio4e_broken;	/* SIO accesses @ 0x4e are broken	*/
+	char *sio_mutex;	/* SIO ACPI mutex			*/
+	u8 skip_pwm;		/* pwm channels to skip for this board	*/
+};
+
+/*
+ * On Gigabyte AB350 and AX370 boards, accesses to the Super-IO chip
+ * at address 0x4e/0x4f can result in a system hang.
+ * Accesses to address 0x2e/0x2f need to be mutex protected.
+ */
+static struct it87_dmi_data gigabyte_ab350_gaming = {
+	.sio4e_broken = true,
+	.sio_mutex = "\\_SB.PCI0.SBRG.SIO1.MUT0",
+};
+
+/*
+ * On the Shuttle SN68PT, FAN_CTL2 is apparently not
+ * connected to a fan, but to something else. One user
+ * has reported instant system power-off when changing
+ * the PWM2 duty cycle, so we disable it.
+ * I use the board name string as the trigger in case
+ * the same board is ever used in other systems.
+ */
+static struct it87_dmi_data nvidia_fn68pt = {
+	.skip_pwm = BIT(1),
+};
+
+static struct it87_dmi_data gigabyte_z87x = {
+	.sio_mutex = "\\_SB.PCI0.LPCB.SIO1.MUT0",
+};
+
+#ifdef CONFIG_SENSORS_IT87_ACPI_MUTEX_CUSTOM_PATH
+static struct it87_dmi_data custom_driver_data = {
+	.sio_mutex = CONFIG_SENSORS_IT87_ACPI_MUTEX_CUSTOM_PATH,
+};
+#endif
+
+static const struct dmi_system_id it87_dmi_table[] __initconst = {
+	{
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Gigabyte Technology Co., Ltd."),
+			DMI_MATCH(DMI_BOARD_NAME, "AB350-Gaming-CF"),
+		},
+		.driver_data = &gigabyte_ab350_gaming,
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Gigabyte Technology Co., Ltd."),
+			DMI_MATCH(DMI_BOARD_NAME, "AB350-Gaming 3-CF"),
+		},
+		.driver_data = &gigabyte_ab350_gaming,
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Gigabyte Technology Co., Ltd."),
+			DMI_MATCH(DMI_BOARD_NAME, "AB350M-D3H-CF"),
+		},
+		.driver_data = &gigabyte_ab350_gaming,
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Gigabyte Technology Co., Ltd."),
+			DMI_MATCH(DMI_BOARD_NAME, "AX370-Gaming K7"),
+		},
+		.driver_data = &gigabyte_ab350_gaming,
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Gigabyte Technology Co., Ltd."),
+			DMI_MATCH(DMI_BOARD_NAME, "AX370-Gaming 5"),
+		},
+		.driver_data = &gigabyte_ab350_gaming,
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Gigabyte Technology Co., Ltd."),
+			DMI_MATCH(DMI_BOARD_NAME, "Z87X-D3H"),
+		},
+		.driver_data = &gigabyte_z87x,
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Gigabyte Technology Co., Ltd."),
+			DMI_MATCH(DMI_BOARD_NAME, "Z87X-D3H-CF"),
+		},
+		.driver_data = &gigabyte_z87x,
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "nVIDIA"),
+			DMI_MATCH(DMI_BOARD_NAME, "FN68PT"),
+		},
+		.driver_data = &nvidia_fn68pt,
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_PRODUCT_NAME, "Milstead Platform"),
+			DMI_MATCH(DMI_BOARD_VERSION, "FABA"),
+			DMI_MATCH(DMI_BIOS_VENDOR, "Phoenix Technologies Ltd."),
+			DMI_MATCH(DMI_BIOS_VERSION, "CDV_T30 X64"),
+		},
+	},
+	{ }
+};
+
 static int __init sm_it87_init(void)
 {
+	const struct dmi_system_id *dmi = dmi_first_match(it87_dmi_table);
+#ifdef CONFIG_SENSORS_IT87_ACPI_MUTEX_CUSTOM_PATH
+	struct it87_dmi_data *dmi_data = &custom_driver_data;
+#else
+	struct it87_dmi_data *dmi_data = NULL;
+#endif
 	int sioaddr[2] = { REG_2E, REG_4E };
 	struct it87_sio_data sio_data;
-	unsigned short isa_address[2];
+	unsigned short isa_address;
 	bool found = false;
 	int i, err;
 
+	if (dmi)
+		dmi_data = dmi->driver_data;
+
+	if (dmi_data) {
+		it87_sio4e_broken = dmi_data->sio4e_broken;
+#ifdef CONFIG_SENSORS_IT87_USE_ACPI_MUTEX
+		if (dmi_data->sio_mutex) {
+			static acpi_status status;
+
+			status = acpi_get_handle(NULL, dmi_data->sio_mutex, &acpi_sio_mutex);
+			if (ACPI_SUCCESS(status)) {
+				pr_debug("Found ACPI SIO mutex %s\n", dmi_data->sio_mutex);
+			} else {
+				acpi_sio_mutex = NULL;
+				pr_warn("ACPI SIO mutex %s not found\n", dmi_data->sio_mutex);
+			}
+		}
+#endif /* CONFIG_SENSORS_IT87_USE_ACPI_MUTEX */
+	}
+
 	err = platform_driver_register(&it87_driver);
 	if (err)
 		return err;
 
 	for (i = 0; i < ARRAY_SIZE(sioaddr); i++) {
-		memset(&sio_data, 0, sizeof(struct it87_sio_data));
-		isa_address[i] = 0;
-		err = it87_find(sioaddr[i], &isa_address[i], &sio_data);
-		if (err || isa_address[i] == 0)
-			continue;
 		/*
-		 * Don't register second chip if its ISA address matches
-		 * the first chip's ISA address.
+		 * Accessing the second Super-IO chip can result in board
+		 * hangs. Disable until we figure out what is going on.
 		 */
-		if (i && isa_address[i] == isa_address[0])
-			break;
+		if (blacklist && it87_sio4e_broken && IS_REG(4E, sioaddr[i]))
+			continue;
+
+		memset(&sio_data, 0, sizeof(struct it87_sio_data));
+		isa_address = 0;
+		err = it87_find(sioaddr[i], &isa_address, &sio_data);
+		if (err || isa_address == 0)
+			continue;
 
-		err = it87_device_add(i, isa_address[i], &sio_data);
+		if (dmi_data)
+			sio_data.skip_pwm |= dmi_data->skip_pwm;
+		err = it87_device_add(i, isa_address, &sio_data);
 		if (err)
 			goto exit_dev_unregister;
-
 		found = true;
-
-		/*
-		 * IT8705F may respond on both SIO addresses.
-		 * Stop probing after finding one.
-		 */
-		if (sio_data.type == it87)
-			break;
 	}
 
 	if (!found) {
@@ -3255,13 +3996,13 @@ static void __exit sm_it87_exit(void)
 	platform_driver_unregister(&it87_driver);
 }
 
+MODULE_DEVICE_TABLE(dmi, it87_dmi_table);
 MODULE_AUTHOR("Chris Gauthron, Jean Delvare <jdelvare@suse.de>");
 MODULE_DESCRIPTION("IT8705F/IT871xF/IT872xF hardware monitoring driver");
 module_param(update_vbat, bool, 0);
 MODULE_PARM_DESC(update_vbat, "Update vbat if set else return powerup value");
 module_param(fix_pwm_polarity, bool, 0);
-MODULE_PARM_DESC(fix_pwm_polarity,
-		 "Force PWM polarity to active high (DANGEROUS)");
+MODULE_PARM_DESC(fix_pwm_polarity, "Force PWM polarity to active high (DANGEROUS)");
 MODULE_LICENSE("GPL");
 
 module_init(sm_it87_init);

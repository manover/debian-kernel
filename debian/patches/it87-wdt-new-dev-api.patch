--- a/drivers/watchdog/it87_wdt.c
+++ b/drivers/watchdog/it87_wdt.c
@@ -37,17 +37,13 @@
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/fs.h>
-#include <linux/miscdevice.h>
 #include <linux/init.h>
 #include <linux/ioport.h>
 #include <linux/watchdog.h>
-#include <linux/notifier.h>
-#include <linux/reboot.h>
 #include <linux/uaccess.h>
 #include <linux/io.h>
 
-
-#define WATCHDOG_VERSION	"1.14"
+#define WATCHDOG_VERSION	"1.15"
 #define WATCHDOG_NAME		"IT87 WDT"
 #define DRIVER_VERSION		WATCHDOG_NAME " driver, v" WATCHDOG_VERSION "\n"
 #define WD_MAGIC		'V'
@@ -132,8 +128,8 @@
 #define GP_BASE_DEFAULT	0x0201
 
 /* wdt_status */
-#define WDTS_TIMER_RUN	0
-#define WDTS_DEV_OPEN	1
+//#define WDTS_TIMER_RUN	0
+//#define WDTS_DEV_OPEN	1
 #define WDTS_KEEPALIVE	2
 #define WDTS_LOCKED	3
 #define WDTS_USE_GP	4
@@ -230,15 +226,14 @@ static inline void superio_outw(int val,
 }
 
 /* Internal function, should be called after superio_select(GPIO) */
-static void wdt_update_timeout(void)
+static void wdt_update_timeout(struct watchdog_device *wdog, unsigned int tm)
 {
 	unsigned char cfg = WDT_KRST;
-	int tm = timeout;
 
 	if (testmode)
 		cfg = 0;
 
-	if (tm <= max_units)
+	if (tm <= wdog->max_timeout)
 		cfg |= WDT_TOV1;
 	else
 		tm /= 60;
@@ -248,7 +243,7 @@ static void wdt_update_timeout(void)
 
 	superio_outb(cfg, WDTCFG);
 	superio_outb(tm, WDTVALLSB);
-	if (max_units > 255)
+	if (wdog->max_timeout > 255)
 		superio_outb(tm>>8, WDTVALMSB);
 }
 
@@ -261,345 +256,147 @@ static int wdt_round_time(int t)
 
 /* watchdog timer handling */
 
-static void wdt_keepalive(void)
+static int wdt_keepalive(struct watchdog_device *wdog)
 {
+	int rc=0;
+
 	if (test_bit(WDTS_USE_GP, &wdt_status))
 		inb(base);
 	else if (test_bit(WDTS_USE_CIR, &wdt_status))
 		/* The timer reloads with around 5 msec delay */
 		outb(0x55, CIR_DR(base));
 	else {
-		if (superio_enter())
-			return;
+		if ((rc = superio_enter()) != 0)
+			return rc;
 
 		superio_select(GPIO);
-		wdt_update_timeout();
+		wdt_update_timeout(wdog, wdog->timeout);
 		superio_exit();
 	}
 	set_bit(WDTS_KEEPALIVE, &wdt_status);
-}
-
-static int wdt_start(void)
-{
-	int ret = superio_enter();
-	if (ret)
-		return ret;
-
-	superio_select(GPIO);
-	if (test_bit(WDTS_USE_GP, &wdt_status))
-		superio_outb(WDT_GAMEPORT, WDTCTRL);
-	else if (test_bit(WDTS_USE_CIR, &wdt_status))
-		superio_outb(WDT_CIRINT, WDTCTRL);
-	wdt_update_timeout();
-
-	superio_exit();
-
-	return 0;
-}
-
-static int wdt_stop(void)
-{
-	int ret = superio_enter();
-	if (ret)
-		return ret;
-
-	superio_select(GPIO);
-	superio_outb(0x00, WDTCTRL);
-	superio_outb(WDT_TOV1, WDTCFG);
-	superio_outb(0x00, WDTVALLSB);
-	if (max_units > 255)
-		superio_outb(0x00, WDTVALMSB);
 
-	superio_exit();
-	return 0;
+	return rc;
 }
 
 /**
- *	wdt_set_timeout - set a new timeout value with watchdog ioctl
+ *	wdt_set_timeout - set a new timeout value
+ *	@wdog: watchdog device
  *	@t: timeout value in seconds
  *
  *	The hardware device has a 8 or 16 bit watchdog timer (depends on
  *	chip version) that can be configured to count seconds or minutes.
  *
- *	Used within WDIOC_SETTIMEOUT watchdog device ioctl.
  */
 
-static int wdt_set_timeout(int t)
+static int wdt_set_timeout(struct watchdog_device *wdog, unsigned int t)
 {
-	if (t < 1 || t > max_units * 60)
+	int rc;
+
+	if (t < 1 || t > wdog->max_timeout * 60)
 		return -EINVAL;
 
-	if (t > max_units)
-		timeout = wdt_round_time(t);
-	else
-		timeout = t;
+	if (t > wdog->max_timeout)
+		t = wdt_round_time(t);
 
-	if (test_bit(WDTS_TIMER_RUN, &wdt_status)) {
-		int ret = superio_enter();
-		if (ret)
-			return ret;
+    pr_info("it87_wdt: wdt_set_timeout(), t = %d\n", t);
 
+	if ((rc = superio_enter()) == 0) {
 		superio_select(GPIO);
-		wdt_update_timeout();
+		wdt_update_timeout(wdog, t);
 		superio_exit();
 	}
-	return 0;
+
+	return rc;
 }
 
 /**
- *	wdt_get_status - determines the status supported by watchdog ioctl
- *	@status: status returned to user space
+ *	wdt_get_time - return time left before watchdog triggers
+ *	@wdog: watchdog device
  *
- *	The status bit of the device does not allow to distinguish
- *	between a regular system reset and a watchdog forced reset.
- *	But, in test mode it is useful, so it is supported through
- *	WDIOC_GETSTATUS watchdog ioctl. Additionally the driver
- *	reports the keepalive signal and the acception of the magic.
- *
- *	Used within WDIOC_GETSTATUS watchdog device ioctl.
+ *	Return: time value in seconds
  */
 
-static int wdt_get_status(int *status)
+static unsigned int wdt_get_time(struct watchdog_device *wdog)
 {
-	*status = 0;
-	if (testmode) {
+	unsigned int t=0;
+
+	pr_info("it87_wdt: wdt_get_time()\n");
+
+	/*if (test_bit(WDTS_TIMER_RUN, &wdt_status)) {*/
+	{
 		int ret = superio_enter();
-		if (ret)
-			return ret;
+		if (ret) {
+			pr_err("it87_wdt: ret=%d when trying to superio_enter() in wdt_get_time()\n", ret);
+			return t;
+		}
 
 		superio_select(GPIO);
-		if (superio_inb(WDTCTRL) & WDT_ZERO) {
-			superio_outb(0x00, WDTCTRL);
-			clear_bit(WDTS_TIMER_RUN, &wdt_status);
-			*status |= WDIOF_CARDRESET;
-		}
+
+		if (wdog->max_timeout > 255)
+			t = superio_inb(WDTVALMSB) << 8;
+		t += superio_inb(WDTVALLSB);
 
 		superio_exit();
 	}
-	if (test_and_clear_bit(WDTS_KEEPALIVE, &wdt_status))
-		*status |= WDIOF_KEEPALIVEPING;
-	if (test_bit(WDTS_EXPECTED, &wdt_status))
-		*status |= WDIOF_MAGICCLOSE;
-	return 0;
+	return t;
 }
 
-/* /dev/watchdog handling */
-
-/**
- *	wdt_open - watchdog file_operations .open
- *	@inode: inode of the device
- *	@file: file handle to the device
- *
- *	The watchdog timer starts by opening the device.
- *
- *	Used within the file operation of the watchdog device.
- */
-
-static int wdt_open(struct inode *inode, struct file *file)
+static int wdt_start(struct watchdog_device *wdog)
 {
-	if (exclusive && test_and_set_bit(WDTS_DEV_OPEN, &wdt_status))
-		return -EBUSY;
-	if (!test_and_set_bit(WDTS_TIMER_RUN, &wdt_status)) {
-		int ret;
-		if (nowayout && !test_and_set_bit(WDTS_LOCKED, &wdt_status))
-			__module_get(THIS_MODULE);
+	int ret = superio_enter();
+	if (ret)
+		return ret;
 
-		ret = wdt_start();
-		if (ret) {
-			clear_bit(WDTS_LOCKED, &wdt_status);
-			clear_bit(WDTS_TIMER_RUN, &wdt_status);
-			clear_bit(WDTS_DEV_OPEN, &wdt_status);
-			return ret;
-		}
-	}
-	return nonseekable_open(inode, file);
-}
+	superio_select(GPIO);
+	if (test_bit(WDTS_USE_GP, &wdt_status))
+		superio_outb(WDT_GAMEPORT, WDTCTRL);
+	else if (test_bit(WDTS_USE_CIR, &wdt_status))
+		superio_outb(WDT_CIRINT, WDTCTRL);
+	wdt_update_timeout(wdog, wdog->timeout);
 
-/**
- *	wdt_release - watchdog file_operations .release
- *	@inode: inode of the device
- *	@file: file handle to the device
- *
- *	Closing the watchdog device either stops the watchdog timer
- *	or in the case, that nowayout is set or the magic character
- *	wasn't written, a critical warning about an running watchdog
- *	timer is given.
- *
- *	Used within the file operation of the watchdog device.
- */
+	superio_exit();
 
-static int wdt_release(struct inode *inode, struct file *file)
-{
-	if (test_bit(WDTS_TIMER_RUN, &wdt_status)) {
-		if (test_and_clear_bit(WDTS_EXPECTED, &wdt_status)) {
-			int ret = wdt_stop();
-			if (ret) {
-				/*
-				 * Stop failed. Just keep the watchdog alive
-				 * and hope nothing bad happens.
-				 */
-				set_bit(WDTS_EXPECTED, &wdt_status);
-				wdt_keepalive();
-				return ret;
-			}
-			clear_bit(WDTS_TIMER_RUN, &wdt_status);
-		} else {
-			wdt_keepalive();
-			pr_crit("unexpected close, not stopping watchdog!\n");
-		}
-	}
-	clear_bit(WDTS_DEV_OPEN, &wdt_status);
 	return 0;
 }
 
-/**
- *	wdt_write - watchdog file_operations .write
- *	@file: file handle to the watchdog
- *	@buf: buffer to write
- *	@count: count of bytes
- *	@ppos: pointer to the position to write. No seeks allowed
- *
- *	A write to a watchdog device is defined as a keepalive signal. Any
- *	write of data will do, as we don't define content meaning.
- *
- *	Used within the file operation of the watchdog device.
- */
-
-static ssize_t wdt_write(struct file *file, const char __user *buf,
-			    size_t count, loff_t *ppos)
-{
-	if (count) {
-		clear_bit(WDTS_EXPECTED, &wdt_status);
-		wdt_keepalive();
-	}
-	if (!nowayout) {
-		size_t ofs;
-
-	/* note: just in case someone wrote the magic character long ago */
-		for (ofs = 0; ofs != count; ofs++) {
-			char c;
-			if (get_user(c, buf + ofs))
-				return -EFAULT;
-			if (c == WD_MAGIC)
-				set_bit(WDTS_EXPECTED, &wdt_status);
-		}
-	}
-	return count;
-}
-
-static const struct watchdog_info ident = {
-	.options = WDIOF_SETTIMEOUT | WDIOF_MAGICCLOSE | WDIOF_KEEPALIVEPING,
-	.firmware_version =	1,
-	.identity = WATCHDOG_NAME,
-};
-
-/**
- *	wdt_ioctl - watchdog file_operations .unlocked_ioctl
- *	@file: file handle to the device
- *	@cmd: watchdog command
- *	@arg: argument pointer
- *
- *	The watchdog API defines a common set of functions for all watchdogs
- *	according to their available features.
- *
- *	Used within the file operation of the watchdog device.
- */
-
-static long wdt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+static int wdt_stop(struct watchdog_device *wdog)
 {
-	int rc = 0, status, new_options, new_timeout;
-	union {
-		struct watchdog_info __user *ident;
-		int __user *i;
-	} uarg;
-
-	uarg.i = (int __user *)arg;
-
-	switch (cmd) {
-	case WDIOC_GETSUPPORT:
-		return copy_to_user(uarg.ident,
-				    &ident, sizeof(ident)) ? -EFAULT : 0;
-
-	case WDIOC_GETSTATUS:
-		rc = wdt_get_status(&status);
-		if (rc)
-			return rc;
-		return put_user(status, uarg.i);
-
-	case WDIOC_GETBOOTSTATUS:
-		return put_user(0, uarg.i);
-
-	case WDIOC_KEEPALIVE:
-		wdt_keepalive();
-		return 0;
-
-	case WDIOC_SETOPTIONS:
-		if (get_user(new_options, uarg.i))
-			return -EFAULT;
-
-		switch (new_options) {
-		case WDIOS_DISABLECARD:
-			if (test_bit(WDTS_TIMER_RUN, &wdt_status)) {
-				rc = wdt_stop();
-				if (rc)
-					return rc;
-			}
-			clear_bit(WDTS_TIMER_RUN, &wdt_status);
-			return 0;
-
-		case WDIOS_ENABLECARD:
-			if (!test_and_set_bit(WDTS_TIMER_RUN, &wdt_status)) {
-				rc = wdt_start();
-				if (rc) {
-					clear_bit(WDTS_TIMER_RUN, &wdt_status);
-					return rc;
-				}
-			}
-			return 0;
-
-		default:
-			return -EFAULT;
-		}
+	int ret = superio_enter();
+	if (ret)
+		return ret;
 
-	case WDIOC_SETTIMEOUT:
-		if (get_user(new_timeout, uarg.i))
-			return -EFAULT;
-		rc = wdt_set_timeout(new_timeout);
-	case WDIOC_GETTIMEOUT:
-		if (put_user(timeout, uarg.i))
-			return -EFAULT;
-		return rc;
+	superio_select(GPIO);
+	superio_outb(0x00, WDTCTRL);
+	superio_outb(WDT_TOV1, WDTCFG);
+	superio_outb(0x00, WDTVALLSB);
+	if (wdog->max_timeout > 255)
+		superio_outb(0x00, WDTVALMSB);
 
-	default:
-		return -ENOTTY;
-	}
+	superio_exit();
+	return 0;
 }
 
-static int wdt_notify_sys(struct notifier_block *this, unsigned long code,
-	void *unused)
-{
-	if (code == SYS_DOWN || code == SYS_HALT)
-		wdt_stop();
-	return NOTIFY_DONE;
-}
+/* Watchdog API */
 
-static const struct file_operations wdt_fops = {
-	.owner		= THIS_MODULE,
-	.llseek		= no_llseek,
-	.write		= wdt_write,
-	.unlocked_ioctl	= wdt_ioctl,
-	.open		= wdt_open,
-	.release	= wdt_release,
+static const struct watchdog_info wdt_info = {
+	.options = WDIOF_SETTIMEOUT | WDIOF_MAGICCLOSE | WDIOF_KEEPALIVEPING,
+	.firmware_version =	1,
+	.identity = WATCHDOG_NAME,
 };
 
-static struct miscdevice wdt_miscdev = {
-	.minor		= WATCHDOG_MINOR,
-	.name		= "watchdog",
-	.fops		= &wdt_fops,
+static const struct watchdog_ops wdt_ops = {
+    .owner = THIS_MODULE,
+    .start = wdt_start,
+    .stop = wdt_stop,
+    .ping = wdt_keepalive,
+    .set_timeout = wdt_set_timeout,
+//    .get_timeleft = wdt_get_time,
 };
 
-static struct notifier_block wdt_notifier = {
-	.notifier_call = wdt_notify_sys,
+static struct watchdog_device wdt_dev = {
+    .info = &wdt_info,
+    .ops = &wdt_ops,
+    .min_timeout = 1,
 };
 
 static int __init it87_wdt_init(void)
@@ -710,19 +507,14 @@ static int __init it87_wdt_init(void)
 	if (timeout > max_units)
 		timeout = wdt_round_time(timeout);
 
-	rc = register_reboot_notifier(&wdt_notifier);
+	wdt_dev.timeout = timeout;
+	wdt_dev.max_timeout = max_units;
+    rc = watchdog_register_device(&wdt_dev);
 	if (rc) {
-		pr_err("Cannot register reboot notifier (err=%d)\n", rc);
+		pr_err("Cannot register a watchdog device (err=%d)\n", rc);
 		goto err_out_region;
 	}
 
-	rc = misc_register(&wdt_miscdev);
-	if (rc) {
-		pr_err("Cannot register miscdev on minor=%d (err=%d)\n",
-		       wdt_miscdev.minor, rc);
-		goto err_out_reboot;
-	}
-
 	/* Initialize CIR to use it as keepalive source */
 	if (test_bit(WDTS_USE_CIR, &wdt_status)) {
 		outb(0x00, CIR_RCR(base));
@@ -741,8 +533,6 @@ static int __init it87_wdt_init(void)
 	superio_exit();
 	return 0;
 
-err_out_reboot:
-	unregister_reboot_notifier(&wdt_notifier);
 err_out_region:
 	if (test_bit(WDTS_USE_GP, &wdt_status))
 		release_region(base, 1);
@@ -780,8 +570,7 @@ static void __exit it87_wdt_exit(void)
 		superio_exit();
 	}
 
-	misc_deregister(&wdt_miscdev);
-	unregister_reboot_notifier(&wdt_notifier);
+    watchdog_unregister_device(&wdt_dev);
 
 	if (test_bit(WDTS_USE_GP, &wdt_status))
 		release_region(base, 1);
